"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/webgl-sdf-generator";
exports.ids = ["vendor-chunks/webgl-sdf-generator"];
exports.modules = {

/***/ "(ssr)/./node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SDFGenerator)\n/* harmony export */ });\nfunction SDFGenerator() {\nvar exports = (function (exports) {\n\n  /**\n   * Find the point on a quadratic bezier curve at t where t is in the range [0, 1]\n   */\n  function pointOnQuadraticBezier (x0, y0, x1, y1, x2, y2, t, pointOut) {\n    var t2 = 1 - t;\n    pointOut.x = t2 * t2 * x0 + 2 * t2 * t * x1 + t * t * x2;\n    pointOut.y = t2 * t2 * y0 + 2 * t2 * t * y1 + t * t * y2;\n  }\n\n  /**\n   * Find the point on a cubic bezier curve at t where t is in the range [0, 1]\n   */\n  function pointOnCubicBezier (x0, y0, x1, y1, x2, y2, x3, y3, t, pointOut) {\n    var t2 = 1 - t;\n    pointOut.x = t2 * t2 * t2 * x0 + 3 * t2 * t2 * t * x1 + 3 * t2 * t * t * x2 + t * t * t * x3;\n    pointOut.y = t2 * t2 * t2 * y0 + 3 * t2 * t2 * t * y1 + 3 * t2 * t * t * y2 + t * t * t * y3;\n  }\n\n  /**\n   * Parse a path string into its constituent line/curve commands, invoking a callback for each.\n   * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z\n   * @param {function(\n   *   command: 'L'|'Q'|'C',\n   *   startX: number,\n   *   startY: number,\n   *   endX: number,\n   *   endY: number,\n   *   ctrl1X?: number,\n   *   ctrl1Y?: number,\n   *   ctrl2X?: number,\n   *   ctrl2Y?: number\n   * )} commandCallback - A callback function that will be called once for each parsed path command, passing the\n   *                      command identifier (only L/Q/C commands) and its numeric arguments.\n   */\n  function forEachPathCommand(pathString, commandCallback) {\n    var segmentRE = /([MLQCZ])([^MLQCZ]*)/g;\n    var match, firstX, firstY, prevX, prevY;\n    while ((match = segmentRE.exec(pathString))) {\n      var args = match[2]\n        .replace(/^\\s*|\\s*$/g, '')\n        .split(/[,\\s]+/)\n        .map(function (v) { return parseFloat(v); });\n      switch (match[1]) {\n        case 'M':\n          prevX = firstX = args[0];\n          prevY = firstY = args[1];\n          break\n        case 'L':\n          if (args[0] !== prevX || args[1] !== prevY) { // yup, some fonts have zero-length line commands\n            commandCallback('L', prevX, prevY, (prevX = args[0]), (prevY = args[1]));\n          }\n          break\n        case 'Q': {\n          commandCallback('Q', prevX, prevY, (prevX = args[2]), (prevY = args[3]), args[0], args[1]);\n          break\n        }\n        case 'C': {\n          commandCallback('C', prevX, prevY, (prevX = args[4]), (prevY = args[5]), args[0], args[1], args[2], args[3]);\n          break\n        }\n        case 'Z':\n          if (prevX !== firstX || prevY !== firstY) {\n            commandCallback('L', prevX, prevY, firstX, firstY);\n          }\n          break\n      }\n    }\n  }\n\n  /**\n   * Convert a path string to a series of straight line segments\n   * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z\n   * @param {function(x1:number, y1:number, x2:number, y2:number)} segmentCallback - A callback\n   *        function that will be called once for every line segment\n   * @param {number} [curvePoints] - How many straight line segments to use when approximating a\n   *        bezier curve in the path. Defaults to 16.\n   */\n  function pathToLineSegments (pathString, segmentCallback, curvePoints) {\n    if ( curvePoints === void 0 ) curvePoints = 16;\n\n    var tempPoint = { x: 0, y: 0 };\n    forEachPathCommand(pathString, function (command, startX, startY, endX, endY, ctrl1X, ctrl1Y, ctrl2X, ctrl2Y) {\n      switch (command) {\n        case 'L':\n          segmentCallback(startX, startY, endX, endY);\n          break\n        case 'Q': {\n          var prevCurveX = startX;\n          var prevCurveY = startY;\n          for (var i = 1; i < curvePoints; i++) {\n            pointOnQuadraticBezier(\n              startX, startY,\n              ctrl1X, ctrl1Y,\n              endX, endY,\n              i / (curvePoints - 1),\n              tempPoint\n            );\n            segmentCallback(prevCurveX, prevCurveY, tempPoint.x, tempPoint.y);\n            prevCurveX = tempPoint.x;\n            prevCurveY = tempPoint.y;\n          }\n          break\n        }\n        case 'C': {\n          var prevCurveX$1 = startX;\n          var prevCurveY$1 = startY;\n          for (var i$1 = 1; i$1 < curvePoints; i$1++) {\n            pointOnCubicBezier(\n              startX, startY,\n              ctrl1X, ctrl1Y,\n              ctrl2X, ctrl2Y,\n              endX, endY,\n              i$1 / (curvePoints - 1),\n              tempPoint\n            );\n            segmentCallback(prevCurveX$1, prevCurveY$1, tempPoint.x, tempPoint.y);\n            prevCurveX$1 = tempPoint.x;\n            prevCurveY$1 = tempPoint.y;\n          }\n          break\n        }\n      }\n    });\n  }\n\n  var viewportQuadVertex = \"precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}\";\n\n  var copyTexFragment = \"precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}\";\n\n  var cache = new WeakMap();\n\n  var glContextParams = {\n    premultipliedAlpha: false,\n    preserveDrawingBuffer: true,\n    antialias: false,\n    depth: false,\n  };\n\n  /**\n   * This is a little helper library for WebGL. It assists with state management for a GL context.\n   * It's pretty tightly wrapped to the needs of this package, not very general-purpose.\n   *\n   * @param { WebGLRenderingContext | HTMLCanvasElement | OffscreenCanvas } glOrCanvas - the GL context to wrap\n   * @param { ({gl, getExtension, withProgram, withTexture, withTextureFramebuffer, handleContextLoss}) => void } callback\n   */\n  function withWebGLContext (glOrCanvas, callback) {\n    var gl = glOrCanvas.getContext ? glOrCanvas.getContext('webgl', glContextParams) : glOrCanvas;\n    var wrapper = cache.get(gl);\n    if (!wrapper) {\n      var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;\n      var extensions = {};\n      var programs = {};\n      var textures = {};\n      var textureUnit = -1;\n      var framebufferStack = [];\n\n      gl.canvas.addEventListener('webglcontextlost', function (e) {\n        handleContextLoss();\n        e.preventDefault();\n      }, false);\n\n      function getExtension (name) {\n        var ext = extensions[name];\n        if (!ext) {\n          ext = extensions[name] = gl.getExtension(name);\n          if (!ext) {\n            throw new Error((name + \" not supported\"))\n          }\n        }\n        return ext\n      }\n\n      function compileShader (src, type) {\n        var shader = gl.createShader(type);\n        gl.shaderSource(shader, src);\n        gl.compileShader(shader);\n        // const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS)\n        // if (!status && !gl.isContextLost()) {\n        //   throw new Error(gl.getShaderInfoLog(shader).trim())\n        // }\n        return shader\n      }\n\n      function withProgram (name, vert, frag, func) {\n        if (!programs[name]) {\n          var attributes = {};\n          var uniforms = {};\n          var program = gl.createProgram();\n          gl.attachShader(program, compileShader(vert, gl.VERTEX_SHADER));\n          gl.attachShader(program, compileShader(frag, gl.FRAGMENT_SHADER));\n          gl.linkProgram(program);\n\n          programs[name] = {\n            program: program,\n            transaction: function transaction (func) {\n              gl.useProgram(program);\n              func({\n                setUniform: function setUniform (type, name) {\n                  var values = [], len = arguments.length - 2;\n                  while ( len-- > 0 ) values[ len ] = arguments[ len + 2 ];\n\n                  var uniformLoc = uniforms[name] || (uniforms[name] = gl.getUniformLocation(program, name));\n                  gl[(\"uniform\" + type)].apply(gl, [ uniformLoc ].concat( values ));\n                },\n\n                setAttribute: function setAttribute (name, size, usage, instancingDivisor, data) {\n                  var attr = attributes[name];\n                  if (!attr) {\n                    attr = attributes[name] = {\n                      buf: gl.createBuffer(), // TODO should we destroy our buffers?\n                      loc: gl.getAttribLocation(program, name),\n                      data: null\n                    };\n                  }\n                  gl.bindBuffer(gl.ARRAY_BUFFER, attr.buf);\n                  gl.vertexAttribPointer(attr.loc, size, gl.FLOAT, false, 0, 0);\n                  gl.enableVertexAttribArray(attr.loc);\n                  if (isWebGL2) {\n                    gl.vertexAttribDivisor(attr.loc, instancingDivisor);\n                  } else {\n                    getExtension('ANGLE_instanced_arrays').vertexAttribDivisorANGLE(attr.loc, instancingDivisor);\n                  }\n                  if (data !== attr.data) {\n                    gl.bufferData(gl.ARRAY_BUFFER, data, usage);\n                    attr.data = data;\n                  }\n                }\n              });\n            }\n          };\n        }\n\n        programs[name].transaction(func);\n      }\n\n      function withTexture (name, func) {\n        textureUnit++;\n        try {\n          gl.activeTexture(gl.TEXTURE0 + textureUnit);\n          var texture = textures[name];\n          if (!texture) {\n            texture = textures[name] = gl.createTexture();\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n          }\n          gl.bindTexture(gl.TEXTURE_2D, texture);\n          func(texture, textureUnit);\n        } finally {\n          textureUnit--;\n        }\n      }\n\n      function withTextureFramebuffer (texture, textureUnit, func) {\n        var framebuffer = gl.createFramebuffer();\n        framebufferStack.push(framebuffer);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n        gl.activeTexture(gl.TEXTURE0 + textureUnit);\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n        try {\n          func(framebuffer);\n        } finally {\n          gl.deleteFramebuffer(framebuffer);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferStack[--framebufferStack.length - 1] || null);\n        }\n      }\n\n      function handleContextLoss () {\n        extensions = {};\n        programs = {};\n        textures = {};\n        textureUnit = -1;\n        framebufferStack.length = 0;\n      }\n\n      cache.set(gl, wrapper = {\n        gl: gl,\n        isWebGL2: isWebGL2,\n        getExtension: getExtension,\n        withProgram: withProgram,\n        withTexture: withTexture,\n        withTextureFramebuffer: withTextureFramebuffer,\n        handleContextLoss: handleContextLoss,\n      });\n    }\n    callback(wrapper);\n  }\n\n\n  function renderImageData(glOrCanvas, imageData, x, y, width, height, channels, framebuffer) {\n    if ( channels === void 0 ) channels = 15;\n    if ( framebuffer === void 0 ) framebuffer = null;\n\n    withWebGLContext(glOrCanvas, function (ref) {\n      var gl = ref.gl;\n      var withProgram = ref.withProgram;\n      var withTexture = ref.withTexture;\n\n      withTexture('copy', function (tex, texUnit) {\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, imageData);\n        withProgram('copy', viewportQuadVertex, copyTexFragment, function (ref) {\n          var setUniform = ref.setUniform;\n          var setAttribute = ref.setAttribute;\n\n          setAttribute('aUV', 2, gl.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2]));\n          setUniform('1i', 'image', texUnit);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer || null);\n          gl.disable(gl.BLEND);\n          gl.colorMask(channels & 8, channels & 4, channels & 2, channels & 1);\n          gl.viewport(x, y, width, height);\n          gl.scissor(x, y, width, height);\n          gl.drawArrays(gl.TRIANGLES, 0, 3);\n        });\n      });\n    });\n  }\n\n  /**\n   * Resizing a canvas clears its contents; this utility copies the previous contents over.\n   * @param canvas\n   * @param newWidth\n   * @param newHeight\n   */\n  function resizeWebGLCanvasWithoutClearing(canvas, newWidth, newHeight) {\n    var width = canvas.width;\n    var height = canvas.height;\n    withWebGLContext(canvas, function (ref) {\n      var gl = ref.gl;\n\n      var data = new Uint8Array(width * height * 4);\n      gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);\n      canvas.width = newWidth;\n      canvas.height = newHeight;\n      renderImageData(gl, data, 0, 0, width, height);\n    });\n  }\n\n  var webglUtils = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    withWebGLContext: withWebGLContext,\n    renderImageData: renderImageData,\n    resizeWebGLCanvasWithoutClearing: resizeWebGLCanvasWithoutClearing\n  });\n\n  function generate$2 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n\n    var textureData = new Uint8Array(sdfWidth * sdfHeight);\n\n    var viewBoxWidth = viewBox[2] - viewBox[0];\n    var viewBoxHeight = viewBox[3] - viewBox[1];\n\n    // Decompose all paths into straight line segments and add them to an index\n    var segments = [];\n    pathToLineSegments(path, function (x1, y1, x2, y2) {\n      segments.push({\n        x1: x1, y1: y1, x2: x2, y2: y2,\n        minX: Math.min(x1, x2),\n        minY: Math.min(y1, y2),\n        maxX: Math.max(x1, x2),\n        maxY: Math.max(y1, y2)\n      });\n    });\n\n    // Sort segments by maxX, this will let us short-circuit some loops below\n    segments.sort(function (a, b) { return a.maxX - b.maxX; });\n\n    // For each target SDF texel, find the distance from its center to its nearest line segment,\n    // map that distance to an alpha value, and write that alpha to the texel\n    for (var sdfX = 0; sdfX < sdfWidth; sdfX++) {\n      for (var sdfY = 0; sdfY < sdfHeight; sdfY++) {\n        var signedDist = findNearestSignedDistance(\n          viewBox[0] + viewBoxWidth * (sdfX + 0.5) / sdfWidth,\n          viewBox[1] + viewBoxHeight * (sdfY + 0.5) / sdfHeight\n        );\n\n        // Use an exponential scale to ensure the texels very near the glyph path have adequate\n        // precision, while allowing the distance field to cover the entire texture, given that\n        // there are only 8 bits available. Formula visualized: https://www.desmos.com/calculator/uiaq5aqiam\n        var alpha = Math.pow((1 - Math.abs(signedDist) / maxDistance), sdfExponent) / 2;\n        if (signedDist < 0) {\n          alpha = 1 - alpha;\n        }\n\n        alpha = Math.max(0, Math.min(255, Math.round(alpha * 255))); //clamp\n        textureData[sdfY * sdfWidth + sdfX] = alpha;\n      }\n    }\n\n    return textureData\n\n    /**\n     * For a given x/y, search the index for the closest line segment and return\n     * its signed distance. Negative = inside, positive = outside, zero = on edge\n     * @param x\n     * @param y\n     * @returns {number}\n     */\n    function findNearestSignedDistance (x, y) {\n      var closestDistSq = Infinity;\n      var closestDist = Infinity;\n\n      for (var i = segments.length; i--;) {\n        var seg = segments[i];\n        if (seg.maxX + closestDist <= x) { break } //sorting by maxX means no more can be closer, so we can short-circuit\n        if (x + closestDist > seg.minX && y - closestDist < seg.maxY && y + closestDist > seg.minY) {\n          var distSq = absSquareDistanceToLineSegment(x, y, seg.x1, seg.y1, seg.x2, seg.y2);\n          if (distSq < closestDistSq) {\n            closestDistSq = distSq;\n            closestDist = Math.sqrt(closestDistSq);\n          }\n        }\n      }\n\n      // Flip to negative distance if inside the poly\n      if (isPointInPoly(x, y)) {\n        closestDist = -closestDist;\n      }\n      return closestDist\n    }\n\n    /**\n     * Determine whether the given point lies inside or outside the glyph. Uses a simple\n     * winding-number ray casting algorithm using a ray pointing east from the point.\n     */\n    function isPointInPoly (x, y) {\n      var winding = 0;\n      for (var i = segments.length; i--;) {\n        var seg = segments[i];\n        if (seg.maxX <= x) { break } //sorting by maxX means no more can cross, so we can short-circuit\n        var intersects = ((seg.y1 > y) !== (seg.y2 > y)) && (x < (seg.x2 - seg.x1) * (y - seg.y1) / (seg.y2 - seg.y1) + seg.x1);\n        if (intersects) {\n          winding += seg.y1 < seg.y2 ? 1 : -1;\n        }\n      }\n      return winding !== 0\n    }\n  }\n\n  function generateIntoCanvas$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    generateIntoFramebuffer$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);\n  }\n\n  function generateIntoFramebuffer$1 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    var data = generate$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent);\n    // Expand single-channel data to rbga\n    var rgbaData = new Uint8Array(data.length * 4);\n    for (var i = 0; i < data.length; i++) {\n      rgbaData[i * 4 + channel] = data[i];\n    }\n    renderImageData(glOrCanvas, rgbaData, x, y, sdfWidth, sdfHeight, 1 << (3 - channel), framebuffer);\n  }\n\n  /**\n   * Find the absolute distance from a point to a line segment at closest approach\n   */\n  function absSquareDistanceToLineSegment (x, y, lineX0, lineY0, lineX1, lineY1) {\n    var ldx = lineX1 - lineX0;\n    var ldy = lineY1 - lineY0;\n    var lengthSq = ldx * ldx + ldy * ldy;\n    var t = lengthSq ? Math.max(0, Math.min(1, ((x - lineX0) * ldx + (y - lineY0) * ldy) / lengthSq)) : 0;\n    var dx = x - (lineX0 + t * ldx);\n    var dy = y - (lineY0 + t * ldy);\n    return dx * dx + dy * dy\n  }\n\n  var javascript = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    generate: generate$2,\n    generateIntoCanvas: generateIntoCanvas$2,\n    generateIntoFramebuffer: generateIntoFramebuffer$1\n  });\n\n  var mainVertex = \"precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}\";\n\n  var mainFragment = \"precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}\";\n\n  var postFragment = \"precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}\";\n\n  // Single triangle covering viewport\n  var viewportUVs = new Float32Array([0, 0, 2, 0, 0, 2]);\n\n  var implicitContext = null;\n  var isTestingSupport = false;\n  var NULL_OBJECT = {};\n  var supportByCanvas = new WeakMap(); // canvas -> bool\n\n  function validateSupport (glOrCanvas) {\n    if (!isTestingSupport && !isSupported(glOrCanvas)) {\n      throw new Error('WebGL generation not supported')\n    }\n  }\n\n  function generate$1 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( glOrCanvas === void 0 ) glOrCanvas = null;\n\n    if (!glOrCanvas) {\n      glOrCanvas = implicitContext;\n      if (!glOrCanvas) {\n        var canvas = typeof OffscreenCanvas === 'function'\n          ? new OffscreenCanvas(1, 1)\n          : typeof document !== 'undefined'\n            ? document.createElement('canvas')\n            : null;\n        if (!canvas) {\n          throw new Error('OffscreenCanvas or DOM canvas not supported')\n        }\n        glOrCanvas = implicitContext = canvas.getContext('webgl', { depth: false });\n      }\n    }\n\n    validateSupport(glOrCanvas);\n\n    var rgbaData = new Uint8Array(sdfWidth * sdfHeight * 4); //not Uint8ClampedArray, cuz Safari\n\n    // Render into a background texture framebuffer\n    withWebGLContext(glOrCanvas, function (ref) {\n      var gl = ref.gl;\n      var withTexture = ref.withTexture;\n      var withTextureFramebuffer = ref.withTextureFramebuffer;\n\n      withTexture('readable', function (texture, textureUnit) {\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sdfWidth, sdfHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n\n        withTextureFramebuffer(texture, textureUnit, function (framebuffer) {\n          generateIntoFramebuffer(\n            sdfWidth,\n            sdfHeight,\n            path,\n            viewBox,\n            maxDistance,\n            sdfExponent,\n            gl,\n            framebuffer,\n            0,\n            0,\n            0 // red channel\n          );\n          gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, rgbaData);\n        });\n      });\n    });\n\n    // Throw away all but the red channel\n    var data = new Uint8Array(sdfWidth * sdfHeight);\n    for (var i = 0, j = 0; i < rgbaData.length; i += 4) {\n      data[j++] = rgbaData[i];\n    }\n\n    return data\n  }\n\n  function generateIntoCanvas$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);\n  }\n\n  function generateIntoFramebuffer (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    // Verify support\n    validateSupport(glOrCanvas);\n\n    // Compute path segments\n    var lineSegmentCoords = [];\n    pathToLineSegments(path, function (x1, y1, x2, y2) {\n      lineSegmentCoords.push(x1, y1, x2, y2);\n    });\n    lineSegmentCoords = new Float32Array(lineSegmentCoords);\n\n    withWebGLContext(glOrCanvas, function (ref) {\n      var gl = ref.gl;\n      var isWebGL2 = ref.isWebGL2;\n      var getExtension = ref.getExtension;\n      var withProgram = ref.withProgram;\n      var withTexture = ref.withTexture;\n      var withTextureFramebuffer = ref.withTextureFramebuffer;\n      var handleContextLoss = ref.handleContextLoss;\n\n      withTexture('rawDistances', function (intermediateTexture, intermediateTextureUnit) {\n        if (sdfWidth !== intermediateTexture._lastWidth || sdfHeight !== intermediateTexture._lastHeight) {\n          gl.texImage2D(\n            gl.TEXTURE_2D, 0, gl.RGBA,\n            intermediateTexture._lastWidth = sdfWidth,\n            intermediateTexture._lastHeight = sdfHeight,\n            0, gl.RGBA, gl.UNSIGNED_BYTE, null\n          );\n        }\n\n        // Unsigned distance pass\n        withProgram('main', mainVertex, mainFragment, function (ref) {\n          var setAttribute = ref.setAttribute;\n          var setUniform = ref.setUniform;\n\n          // Init extensions\n          var instancingExtension = !isWebGL2 && getExtension('ANGLE_instanced_arrays');\n          var blendMinMaxExtension = !isWebGL2 && getExtension('EXT_blend_minmax');\n\n          // Init/update attributes\n          setAttribute('aUV', 2, gl.STATIC_DRAW, 0, viewportUVs);\n          setAttribute('aLineSegment', 4, gl.DYNAMIC_DRAW, 1, lineSegmentCoords);\n\n          // Init/update uniforms\n          setUniform.apply(void 0, [ '4f', 'uGlyphBounds' ].concat( viewBox ));\n          setUniform('1f', 'uMaxDistance', maxDistance);\n          setUniform('1f', 'uExponent', sdfExponent);\n\n          // Render initial unsigned distance / winding number info to a texture\n          withTextureFramebuffer(intermediateTexture, intermediateTextureUnit, function (framebuffer) {\n            gl.enable(gl.BLEND);\n            gl.colorMask(true, true, true, true);\n            gl.viewport(0, 0, sdfWidth, sdfHeight);\n            gl.scissor(0, 0, sdfWidth, sdfHeight);\n            gl.blendFunc(gl.ONE, gl.ONE);\n            // Red+Green channels are incremented (FUNC_ADD) for segment-ray crossings to give a \"winding number\".\n            // Alpha holds the closest (MAX) unsigned distance.\n            gl.blendEquationSeparate(gl.FUNC_ADD, isWebGL2 ? gl.MAX : blendMinMaxExtension.MAX_EXT);\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            if (isWebGL2) {\n              gl.drawArraysInstanced(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);\n            } else {\n              instancingExtension.drawArraysInstancedANGLE(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);\n            }\n            // Debug\n            // const debug = new Uint8Array(sdfWidth * sdfHeight * 4)\n            // gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, debug)\n            // console.log('intermediate texture data: ', debug)\n          });\n        });\n\n        // Use the data stored in the texture to apply inside/outside and write to the output framebuffer rect+channel.\n        withProgram('post', viewportQuadVertex, postFragment, function (program) {\n          program.setAttribute('aUV', 2, gl.STATIC_DRAW, 0, viewportUVs);\n          program.setUniform('1i', 'tex', intermediateTextureUnit);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n          gl.disable(gl.BLEND);\n          gl.colorMask(channel === 0, channel === 1, channel === 2, channel === 3);\n          gl.viewport(x, y, sdfWidth, sdfHeight);\n          gl.scissor(x, y, sdfWidth, sdfHeight);\n          gl.drawArrays(gl.TRIANGLES, 0, 3);\n        });\n      });\n\n      // Handle context loss occurring during any of the above calls\n      if (gl.isContextLost()) {\n        handleContextLoss();\n        throw new Error('webgl context lost')\n      }\n    });\n  }\n\n  function isSupported (glOrCanvas) {\n    var key = (!glOrCanvas || glOrCanvas === implicitContext) ? NULL_OBJECT : (glOrCanvas.canvas || glOrCanvas);\n    var supported = supportByCanvas.get(key);\n    if (supported === undefined) {\n      isTestingSupport = true;\n      var failReason = null;\n      try {\n        // Since we can't detect all failure modes up front, let's just do a trial run of a\n        // simple path and compare what we get back to the correct expected result. This will\n        // also serve to prime the shader compilation.\n        var expectedResult = [\n          97, 106, 97, 61,\n          99, 137, 118, 80,\n          80, 118, 137, 99,\n          61, 97, 106, 97\n        ];\n        var testResult = generate$1(\n          4,\n          4,\n          'M8,8L16,8L24,24L16,24Z',\n          [0, 0, 32, 32],\n          24,\n          1,\n          glOrCanvas\n        );\n        supported = testResult && expectedResult.length === testResult.length &&\n          testResult.every(function (val, i) { return val === expectedResult[i]; });\n        if (!supported) {\n          failReason = 'bad trial run results';\n          console.info(expectedResult, testResult);\n        }\n      } catch (err) {\n        // TODO if it threw due to webgl context loss, should we maybe leave isSupported as null and try again later?\n        supported = false;\n        failReason = err.message;\n      }\n      if (failReason) {\n        console.warn('WebGL SDF generation not supported:', failReason);\n      }\n      isTestingSupport = false;\n      supportByCanvas.set(key, supported);\n    }\n    return supported\n  }\n\n  var webgl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    generate: generate$1,\n    generateIntoCanvas: generateIntoCanvas$1,\n    generateIntoFramebuffer: generateIntoFramebuffer,\n    isSupported: isSupported\n  });\n\n  /**\n   * Generate an SDF texture image for a 2D path.\n   *\n   * @param {number} sdfWidth - width of the SDF output image in pixels.\n   * @param {number} sdfHeight - height of the SDF output image in pixels.\n   * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.\n   * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.\n   * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults\n   *        to half the maximum viewBox dimension.\n   * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents\n   *        will give greater precision nearer the glyph's path.\n   * @return {Uint8Array}\n   */\n  function generate(\n    sdfWidth,\n    sdfHeight,\n    path,\n    viewBox,\n    maxDistance,\n    sdfExponent\n  ) {\n    if ( maxDistance === void 0 ) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n\n    try {\n      return generate$1.apply(webgl, arguments)\n    } catch(e) {\n      console.info('WebGL SDF generation failed, falling back to JS', e);\n      return generate$2.apply(javascript, arguments)\n    }\n  }\n\n  /**\n   * Generate an SDF texture image for a 2D path, inserting the result into a WebGL `canvas` at a given x/y position\n   * and color channel. This is generally much faster than calling `generate` because it does not require reading pixels\n   * back from the GPU->CPU -- the `canvas` can be used directly as a WebGL texture image, so it all stays on the GPU.\n   *\n   * @param {number} sdfWidth - width of the SDF output image in pixels.\n   * @param {number} sdfHeight - height of the SDF output image in pixels.\n   * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.\n   * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.\n   * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults\n   *        to half the maximum viewBox dimension.\n   * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents\n   *        will give greater precision nearer the glyph's path.\n   * @param {HTMLCanvasElement|OffscreenCanvas} canvas - a WebGL-enabled canvas into which the SDF will be rendered.\n   *        Only the relevant rect/channel will be modified, the rest will be preserved. To avoid unpredictable results\n   *        due to shared GL context state, this canvas should be dedicated to use by this library alone.\n   * @param {number} x - the x position at which to render the SDF.\n   * @param {number} y - the y position at which to render the SDF.\n   * @param {number} channel - the color channel index (0-4) into which the SDF will be rendered.\n   * @return {Uint8Array}\n   */\n  function generateIntoCanvas(\n    sdfWidth,\n    sdfHeight,\n    path,\n    viewBox,\n    maxDistance,\n    sdfExponent,\n    canvas,\n    x,\n    y,\n    channel\n  ) {\n    if ( maxDistance === void 0 ) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    try {\n      return generateIntoCanvas$1.apply(webgl, arguments)\n    } catch(e) {\n      console.info('WebGL SDF generation failed, falling back to JS', e);\n      return generateIntoCanvas$2.apply(javascript, arguments)\n    }\n  }\n\n  exports.forEachPathCommand = forEachPathCommand;\n  exports.generate = generate;\n  exports.generateIntoCanvas = generateIntoCanvas;\n  exports.javascript = javascript;\n  exports.pathToLineSegments = pathToLineSegments;\n  exports.webgl = webgl;\n  exports.webglUtils = webglUtils;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n}({}));\nreturn exports\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViZ2wtc2RmLWdlbmVyYXRvci9kaXN0L3dlYmdsLXNkZi1nZW5lcmF0b3IubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRLCtDQUErQztBQUNwRSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVEsK0NBQStDO0FBQ3BFLGFBQWEsc0RBQXNEO0FBQ25FO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLGtEQUFrRCxtQkFBbUIsaUJBQWlCLFlBQVksUUFBUSx5REFB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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUSxxREFBcUQ7QUFDMUUsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsUUFBUSwyRkFBMkY7QUFDaEg7QUFDQSxhQUFhLFFBQVEsOEVBQThFO0FBQ25HO0FBQ0EsYUFBYSxtQ0FBbUM7QUFDaEQ7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQsYUFBYTs7QUFFOUQ7O0FBRUEsQ0FBQyxHQUFHO0FBQ0o7QUFDQTs7QUFFbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pdHZleG8tcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL3dlYmdsLXNkZi1nZW5lcmF0b3IvZGlzdC93ZWJnbC1zZGYtZ2VuZXJhdG9yLm1qcz9kNzJlIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIFNERkdlbmVyYXRvcigpIHtcbnZhciBleHBvcnRzID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIHBvaW50IG9uIGEgcXVhZHJhdGljIGJlemllciBjdXJ2ZSBhdCB0IHdoZXJlIHQgaXMgaW4gdGhlIHJhbmdlIFswLCAxXVxuICAgKi9cbiAgZnVuY3Rpb24gcG9pbnRPblF1YWRyYXRpY0JlemllciAoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgdCwgcG9pbnRPdXQpIHtcbiAgICB2YXIgdDIgPSAxIC0gdDtcbiAgICBwb2ludE91dC54ID0gdDIgKiB0MiAqIHgwICsgMiAqIHQyICogdCAqIHgxICsgdCAqIHQgKiB4MjtcbiAgICBwb2ludE91dC55ID0gdDIgKiB0MiAqIHkwICsgMiAqIHQyICogdCAqIHkxICsgdCAqIHQgKiB5MjtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBwb2ludCBvbiBhIGN1YmljIGJlemllciBjdXJ2ZSBhdCB0IHdoZXJlIHQgaXMgaW4gdGhlIHJhbmdlIFswLCAxXVxuICAgKi9cbiAgZnVuY3Rpb24gcG9pbnRPbkN1YmljQmV6aWVyICh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHQsIHBvaW50T3V0KSB7XG4gICAgdmFyIHQyID0gMSAtIHQ7XG4gICAgcG9pbnRPdXQueCA9IHQyICogdDIgKiB0MiAqIHgwICsgMyAqIHQyICogdDIgKiB0ICogeDEgKyAzICogdDIgKiB0ICogdCAqIHgyICsgdCAqIHQgKiB0ICogeDM7XG4gICAgcG9pbnRPdXQueSA9IHQyICogdDIgKiB0MiAqIHkwICsgMyAqIHQyICogdDIgKiB0ICogeTEgKyAzICogdDIgKiB0ICogdCAqIHkyICsgdCAqIHQgKiB0ICogeTM7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgYSBwYXRoIHN0cmluZyBpbnRvIGl0cyBjb25zdGl0dWVudCBsaW5lL2N1cnZlIGNvbW1hbmRzLCBpbnZva2luZyBhIGNhbGxiYWNrIGZvciBlYWNoLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aFN0cmluZyAtIEFuIFNWRy1saWtlIHBhdGggc3RyaW5nIHRvIHBhcnNlOyBzaG91bGQgb25seSBjb250YWluIGNvbW1hbmRzOiBNL0wvUS9DL1pcbiAgICogQHBhcmFtIHtmdW5jdGlvbihcbiAgICogICBjb21tYW5kOiAnTCd8J1EnfCdDJyxcbiAgICogICBzdGFydFg6IG51bWJlcixcbiAgICogICBzdGFydFk6IG51bWJlcixcbiAgICogICBlbmRYOiBudW1iZXIsXG4gICAqICAgZW5kWTogbnVtYmVyLFxuICAgKiAgIGN0cmwxWD86IG51bWJlcixcbiAgICogICBjdHJsMVk/OiBudW1iZXIsXG4gICAqICAgY3RybDJYPzogbnVtYmVyLFxuICAgKiAgIGN0cmwyWT86IG51bWJlclxuICAgKiApfSBjb21tYW5kQ2FsbGJhY2sgLSBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgb25jZSBmb3IgZWFjaCBwYXJzZWQgcGF0aCBjb21tYW5kLCBwYXNzaW5nIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kIGlkZW50aWZpZXIgKG9ubHkgTC9RL0MgY29tbWFuZHMpIGFuZCBpdHMgbnVtZXJpYyBhcmd1bWVudHMuXG4gICAqL1xuICBmdW5jdGlvbiBmb3JFYWNoUGF0aENvbW1hbmQocGF0aFN0cmluZywgY29tbWFuZENhbGxiYWNrKSB7XG4gICAgdmFyIHNlZ21lbnRSRSA9IC8oW01MUUNaXSkoW15NTFFDWl0qKS9nO1xuICAgIHZhciBtYXRjaCwgZmlyc3RYLCBmaXJzdFksIHByZXZYLCBwcmV2WTtcbiAgICB3aGlsZSAoKG1hdGNoID0gc2VnbWVudFJFLmV4ZWMocGF0aFN0cmluZykpKSB7XG4gICAgICB2YXIgYXJncyA9IG1hdGNoWzJdXG4gICAgICAgIC5yZXBsYWNlKC9eXFxzKnxcXHMqJC9nLCAnJylcbiAgICAgICAgLnNwbGl0KC9bLFxcc10rLylcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gcGFyc2VGbG9hdCh2KTsgfSk7XG4gICAgICBzd2l0Y2ggKG1hdGNoWzFdKSB7XG4gICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgIHByZXZYID0gZmlyc3RYID0gYXJnc1swXTtcbiAgICAgICAgICBwcmV2WSA9IGZpcnN0WSA9IGFyZ3NbMV07XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgaWYgKGFyZ3NbMF0gIT09IHByZXZYIHx8IGFyZ3NbMV0gIT09IHByZXZZKSB7IC8vIHl1cCwgc29tZSBmb250cyBoYXZlIHplcm8tbGVuZ3RoIGxpbmUgY29tbWFuZHNcbiAgICAgICAgICAgIGNvbW1hbmRDYWxsYmFjaygnTCcsIHByZXZYLCBwcmV2WSwgKHByZXZYID0gYXJnc1swXSksIChwcmV2WSA9IGFyZ3NbMV0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnUSc6IHtcbiAgICAgICAgICBjb21tYW5kQ2FsbGJhY2soJ1EnLCBwcmV2WCwgcHJldlksIChwcmV2WCA9IGFyZ3NbMl0pLCAocHJldlkgPSBhcmdzWzNdKSwgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdDJzoge1xuICAgICAgICAgIGNvbW1hbmRDYWxsYmFjaygnQycsIHByZXZYLCBwcmV2WSwgKHByZXZYID0gYXJnc1s0XSksIChwcmV2WSA9IGFyZ3NbNV0pLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgIGlmIChwcmV2WCAhPT0gZmlyc3RYIHx8IHByZXZZICE9PSBmaXJzdFkpIHtcbiAgICAgICAgICAgIGNvbW1hbmRDYWxsYmFjaygnTCcsIHByZXZYLCBwcmV2WSwgZmlyc3RYLCBmaXJzdFkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgcGF0aCBzdHJpbmcgdG8gYSBzZXJpZXMgb2Ygc3RyYWlnaHQgbGluZSBzZWdtZW50c1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aFN0cmluZyAtIEFuIFNWRy1saWtlIHBhdGggc3RyaW5nIHRvIHBhcnNlOyBzaG91bGQgb25seSBjb250YWluIGNvbW1hbmRzOiBNL0wvUS9DL1pcbiAgICogQHBhcmFtIHtmdW5jdGlvbih4MTpudW1iZXIsIHkxOm51bWJlciwgeDI6bnVtYmVyLCB5MjpudW1iZXIpfSBzZWdtZW50Q2FsbGJhY2sgLSBBIGNhbGxiYWNrXG4gICAqICAgICAgICBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIG9uY2UgZm9yIGV2ZXJ5IGxpbmUgc2VnbWVudFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2N1cnZlUG9pbnRzXSAtIEhvdyBtYW55IHN0cmFpZ2h0IGxpbmUgc2VnbWVudHMgdG8gdXNlIHdoZW4gYXBwcm94aW1hdGluZyBhXG4gICAqICAgICAgICBiZXppZXIgY3VydmUgaW4gdGhlIHBhdGguIERlZmF1bHRzIHRvIDE2LlxuICAgKi9cbiAgZnVuY3Rpb24gcGF0aFRvTGluZVNlZ21lbnRzIChwYXRoU3RyaW5nLCBzZWdtZW50Q2FsbGJhY2ssIGN1cnZlUG9pbnRzKSB7XG4gICAgaWYgKCBjdXJ2ZVBvaW50cyA9PT0gdm9pZCAwICkgY3VydmVQb2ludHMgPSAxNjtcblxuICAgIHZhciB0ZW1wUG9pbnQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICBmb3JFYWNoUGF0aENvbW1hbmQocGF0aFN0cmluZywgZnVuY3Rpb24gKGNvbW1hbmQsIHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZLCBjdHJsMVgsIGN0cmwxWSwgY3RybDJYLCBjdHJsMlkpIHtcbiAgICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICBzZWdtZW50Q2FsbGJhY2soc3RhcnRYLCBzdGFydFksIGVuZFgsIGVuZFkpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ1EnOiB7XG4gICAgICAgICAgdmFyIHByZXZDdXJ2ZVggPSBzdGFydFg7XG4gICAgICAgICAgdmFyIHByZXZDdXJ2ZVkgPSBzdGFydFk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBjdXJ2ZVBvaW50czsgaSsrKSB7XG4gICAgICAgICAgICBwb2ludE9uUXVhZHJhdGljQmV6aWVyKFxuICAgICAgICAgICAgICBzdGFydFgsIHN0YXJ0WSxcbiAgICAgICAgICAgICAgY3RybDFYLCBjdHJsMVksXG4gICAgICAgICAgICAgIGVuZFgsIGVuZFksXG4gICAgICAgICAgICAgIGkgLyAoY3VydmVQb2ludHMgLSAxKSxcbiAgICAgICAgICAgICAgdGVtcFBvaW50XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgc2VnbWVudENhbGxiYWNrKHByZXZDdXJ2ZVgsIHByZXZDdXJ2ZVksIHRlbXBQb2ludC54LCB0ZW1wUG9pbnQueSk7XG4gICAgICAgICAgICBwcmV2Q3VydmVYID0gdGVtcFBvaW50Lng7XG4gICAgICAgICAgICBwcmV2Q3VydmVZID0gdGVtcFBvaW50Lnk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnQyc6IHtcbiAgICAgICAgICB2YXIgcHJldkN1cnZlWCQxID0gc3RhcnRYO1xuICAgICAgICAgIHZhciBwcmV2Q3VydmVZJDEgPSBzdGFydFk7XG4gICAgICAgICAgZm9yICh2YXIgaSQxID0gMTsgaSQxIDwgY3VydmVQb2ludHM7IGkkMSsrKSB7XG4gICAgICAgICAgICBwb2ludE9uQ3ViaWNCZXppZXIoXG4gICAgICAgICAgICAgIHN0YXJ0WCwgc3RhcnRZLFxuICAgICAgICAgICAgICBjdHJsMVgsIGN0cmwxWSxcbiAgICAgICAgICAgICAgY3RybDJYLCBjdHJsMlksXG4gICAgICAgICAgICAgIGVuZFgsIGVuZFksXG4gICAgICAgICAgICAgIGkkMSAvIChjdXJ2ZVBvaW50cyAtIDEpLFxuICAgICAgICAgICAgICB0ZW1wUG9pbnRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzZWdtZW50Q2FsbGJhY2socHJldkN1cnZlWCQxLCBwcmV2Q3VydmVZJDEsIHRlbXBQb2ludC54LCB0ZW1wUG9pbnQueSk7XG4gICAgICAgICAgICBwcmV2Q3VydmVYJDEgPSB0ZW1wUG9pbnQueDtcbiAgICAgICAgICAgIHByZXZDdXJ2ZVkkMSA9IHRlbXBQb2ludC55O1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgdmlld3BvcnRRdWFkVmVydGV4ID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7YXR0cmlidXRlIHZlYzIgYVVWO3ZhcnlpbmcgdmVjMiB2VVY7dm9pZCBtYWluKCl7dlVWPWFVVjtnbF9Qb3NpdGlvbj12ZWM0KG1peCh2ZWMyKC0xLjApLHZlYzIoMS4wKSxhVVYpLDAuMCwxLjApO31cIjtcblxuICB2YXIgY29weVRleEZyYWdtZW50ID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7dW5pZm9ybSBzYW1wbGVyMkQgdGV4O3ZhcnlpbmcgdmVjMiB2VVY7dm9pZCBtYWluKCl7Z2xfRnJhZ0NvbG9yPXRleHR1cmUyRCh0ZXgsdlVWKTt9XCI7XG5cbiAgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTtcblxuICB2YXIgZ2xDb250ZXh0UGFyYW1zID0ge1xuICAgIHByZW11bHRpcGxpZWRBbHBoYTogZmFsc2UsXG4gICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiB0cnVlLFxuICAgIGFudGlhbGlhczogZmFsc2UsXG4gICAgZGVwdGg6IGZhbHNlLFxuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgbGl0dGxlIGhlbHBlciBsaWJyYXJ5IGZvciBXZWJHTC4gSXQgYXNzaXN0cyB3aXRoIHN0YXRlIG1hbmFnZW1lbnQgZm9yIGEgR0wgY29udGV4dC5cbiAgICogSXQncyBwcmV0dHkgdGlnaHRseSB3cmFwcGVkIHRvIHRoZSBuZWVkcyBvZiB0aGlzIHBhY2thZ2UsIG5vdCB2ZXJ5IGdlbmVyYWwtcHVycG9zZS5cbiAgICpcbiAgICogQHBhcmFtIHsgV2ViR0xSZW5kZXJpbmdDb250ZXh0IHwgSFRNTENhbnZhc0VsZW1lbnQgfCBPZmZzY3JlZW5DYW52YXMgfSBnbE9yQ2FudmFzIC0gdGhlIEdMIGNvbnRleHQgdG8gd3JhcFxuICAgKiBAcGFyYW0geyAoe2dsLCBnZXRFeHRlbnNpb24sIHdpdGhQcm9ncmFtLCB3aXRoVGV4dHVyZSwgd2l0aFRleHR1cmVGcmFtZWJ1ZmZlciwgaGFuZGxlQ29udGV4dExvc3N9KSA9PiB2b2lkIH0gY2FsbGJhY2tcbiAgICovXG4gIGZ1bmN0aW9uIHdpdGhXZWJHTENvbnRleHQgKGdsT3JDYW52YXMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGdsID0gZ2xPckNhbnZhcy5nZXRDb250ZXh0ID8gZ2xPckNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIGdsQ29udGV4dFBhcmFtcykgOiBnbE9yQ2FudmFzO1xuICAgIHZhciB3cmFwcGVyID0gY2FjaGUuZ2V0KGdsKTtcbiAgICBpZiAoIXdyYXBwZXIpIHtcbiAgICAgIHZhciBpc1dlYkdMMiA9IHR5cGVvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ICE9PSAndW5kZWZpbmVkJyAmJiBnbCBpbnN0YW5jZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ7XG4gICAgICB2YXIgZXh0ZW5zaW9ucyA9IHt9O1xuICAgICAgdmFyIHByb2dyYW1zID0ge307XG4gICAgICB2YXIgdGV4dHVyZXMgPSB7fTtcbiAgICAgIHZhciB0ZXh0dXJlVW5pdCA9IC0xO1xuICAgICAgdmFyIGZyYW1lYnVmZmVyU3RhY2sgPSBbXTtcblxuICAgICAgZ2wuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBoYW5kbGVDb250ZXh0TG9zcygpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9LCBmYWxzZSk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldEV4dGVuc2lvbiAobmFtZSkge1xuICAgICAgICB2YXIgZXh0ID0gZXh0ZW5zaW9uc1tuYW1lXTtcbiAgICAgICAgaWYgKCFleHQpIHtcbiAgICAgICAgICBleHQgPSBleHRlbnNpb25zW25hbWVdID0gZ2wuZ2V0RXh0ZW5zaW9uKG5hbWUpO1xuICAgICAgICAgIGlmICghZXh0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKG5hbWUgKyBcIiBub3Qgc3VwcG9ydGVkXCIpKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXh0XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNvbXBpbGVTaGFkZXIgKHNyYywgdHlwZSkge1xuICAgICAgICB2YXIgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xuICAgICAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzcmMpO1xuICAgICAgICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG4gICAgICAgIC8vIGNvbnN0IHN0YXR1cyA9IGdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKVxuICAgICAgICAvLyBpZiAoIXN0YXR1cyAmJiAhZ2wuaXNDb250ZXh0TG9zdCgpKSB7XG4gICAgICAgIC8vICAgdGhyb3cgbmV3IEVycm9yKGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKS50cmltKCkpXG4gICAgICAgIC8vIH1cbiAgICAgICAgcmV0dXJuIHNoYWRlclxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB3aXRoUHJvZ3JhbSAobmFtZSwgdmVydCwgZnJhZywgZnVuYykge1xuICAgICAgICBpZiAoIXByb2dyYW1zW25hbWVdKSB7XG4gICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgICB2YXIgdW5pZm9ybXMgPSB7fTtcbiAgICAgICAgICB2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICAgICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgY29tcGlsZVNoYWRlcih2ZXJ0LCBnbC5WRVJURVhfU0hBREVSKSk7XG4gICAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGNvbXBpbGVTaGFkZXIoZnJhZywgZ2wuRlJBR01FTlRfU0hBREVSKSk7XG4gICAgICAgICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG5cbiAgICAgICAgICBwcm9ncmFtc1tuYW1lXSA9IHtcbiAgICAgICAgICAgIHByb2dyYW06IHByb2dyYW0sXG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogZnVuY3Rpb24gdHJhbnNhY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgICAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgICAgICAgZnVuYyh7XG4gICAgICAgICAgICAgICAgc2V0VW5pZm9ybTogZnVuY3Rpb24gc2V0VW5pZm9ybSAodHlwZSwgbmFtZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgICAgICAgICAgICAgICAgIHdoaWxlICggbGVuLS0gPiAwICkgdmFsdWVzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMiBdO1xuXG4gICAgICAgICAgICAgICAgICB2YXIgdW5pZm9ybUxvYyA9IHVuaWZvcm1zW25hbWVdIHx8ICh1bmlmb3Jtc1tuYW1lXSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBuYW1lKSk7XG4gICAgICAgICAgICAgICAgICBnbFsoXCJ1bmlmb3JtXCIgKyB0eXBlKV0uYXBwbHkoZ2wsIFsgdW5pZm9ybUxvYyBdLmNvbmNhdCggdmFsdWVzICkpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBzZXRBdHRyaWJ1dGU6IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZSAobmFtZSwgc2l6ZSwgdXNhZ2UsIGluc3RhbmNpbmdEaXZpc29yLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IGF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgICBpZiAoIWF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0ciA9IGF0dHJpYnV0ZXNbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgYnVmOiBnbC5jcmVhdGVCdWZmZXIoKSwgLy8gVE9ETyBzaG91bGQgd2UgZGVzdHJveSBvdXIgYnVmZmVycz9cbiAgICAgICAgICAgICAgICAgICAgICBsb2M6IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIG5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBhdHRyLmJ1Zik7XG4gICAgICAgICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGF0dHIubG9jLCBzaXplLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgICAgICAgICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYXR0ci5sb2MpO1xuICAgICAgICAgICAgICAgICAgaWYgKGlzV2ViR0wyKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYkRpdmlzb3IoYXR0ci5sb2MsIGluc3RhbmNpbmdEaXZpc29yKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdldEV4dGVuc2lvbignQU5HTEVfaW5zdGFuY2VkX2FycmF5cycpLnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRShhdHRyLmxvYywgaW5zdGFuY2luZ0Rpdmlzb3IpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgIT09IGF0dHIuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZGF0YSwgdXNhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBhdHRyLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb2dyYW1zW25hbWVdLnRyYW5zYWN0aW9uKGZ1bmMpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB3aXRoVGV4dHVyZSAobmFtZSwgZnVuYykge1xuICAgICAgICB0ZXh0dXJlVW5pdCsrO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0ZXh0dXJlVW5pdCk7XG4gICAgICAgICAgdmFyIHRleHR1cmUgPSB0ZXh0dXJlc1tuYW1lXTtcbiAgICAgICAgICBpZiAoIXRleHR1cmUpIHtcbiAgICAgICAgICAgIHRleHR1cmUgPSB0ZXh0dXJlc1tuYW1lXSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICAgICAgICBmdW5jKHRleHR1cmUsIHRleHR1cmVVbml0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0ZXh0dXJlVW5pdC0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHdpdGhUZXh0dXJlRnJhbWVidWZmZXIgKHRleHR1cmUsIHRleHR1cmVVbml0LCBmdW5jKSB7XG4gICAgICAgIHZhciBmcmFtZWJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgICAgIGZyYW1lYnVmZmVyU3RhY2sucHVzaChmcmFtZWJ1ZmZlcik7XG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIpO1xuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGV4dHVyZVVuaXQpO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlLCAwKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmdW5jKGZyYW1lYnVmZmVyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcik7XG4gICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlclN0YWNrWy0tZnJhbWVidWZmZXJTdGFjay5sZW5ndGggLSAxXSB8fCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVDb250ZXh0TG9zcyAoKSB7XG4gICAgICAgIGV4dGVuc2lvbnMgPSB7fTtcbiAgICAgICAgcHJvZ3JhbXMgPSB7fTtcbiAgICAgICAgdGV4dHVyZXMgPSB7fTtcbiAgICAgICAgdGV4dHVyZVVuaXQgPSAtMTtcbiAgICAgICAgZnJhbWVidWZmZXJTdGFjay5sZW5ndGggPSAwO1xuICAgICAgfVxuXG4gICAgICBjYWNoZS5zZXQoZ2wsIHdyYXBwZXIgPSB7XG4gICAgICAgIGdsOiBnbCxcbiAgICAgICAgaXNXZWJHTDI6IGlzV2ViR0wyLFxuICAgICAgICBnZXRFeHRlbnNpb246IGdldEV4dGVuc2lvbixcbiAgICAgICAgd2l0aFByb2dyYW06IHdpdGhQcm9ncmFtLFxuICAgICAgICB3aXRoVGV4dHVyZTogd2l0aFRleHR1cmUsXG4gICAgICAgIHdpdGhUZXh0dXJlRnJhbWVidWZmZXI6IHdpdGhUZXh0dXJlRnJhbWVidWZmZXIsXG4gICAgICAgIGhhbmRsZUNvbnRleHRMb3NzOiBoYW5kbGVDb250ZXh0TG9zcyxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjYWxsYmFjayh3cmFwcGVyKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gcmVuZGVySW1hZ2VEYXRhKGdsT3JDYW52YXMsIGltYWdlRGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgY2hhbm5lbHMsIGZyYW1lYnVmZmVyKSB7XG4gICAgaWYgKCBjaGFubmVscyA9PT0gdm9pZCAwICkgY2hhbm5lbHMgPSAxNTtcbiAgICBpZiAoIGZyYW1lYnVmZmVyID09PSB2b2lkIDAgKSBmcmFtZWJ1ZmZlciA9IG51bGw7XG5cbiAgICB3aXRoV2ViR0xDb250ZXh0KGdsT3JDYW52YXMsIGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgIHZhciBnbCA9IHJlZi5nbDtcbiAgICAgIHZhciB3aXRoUHJvZ3JhbSA9IHJlZi53aXRoUHJvZ3JhbTtcbiAgICAgIHZhciB3aXRoVGV4dHVyZSA9IHJlZi53aXRoVGV4dHVyZTtcblxuICAgICAgd2l0aFRleHR1cmUoJ2NvcHknLCBmdW5jdGlvbiAodGV4LCB0ZXhVbml0KSB7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgd2lkdGgsIGhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgaW1hZ2VEYXRhKTtcbiAgICAgICAgd2l0aFByb2dyYW0oJ2NvcHknLCB2aWV3cG9ydFF1YWRWZXJ0ZXgsIGNvcHlUZXhGcmFnbWVudCwgZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgIHZhciBzZXRVbmlmb3JtID0gcmVmLnNldFVuaWZvcm07XG4gICAgICAgICAgdmFyIHNldEF0dHJpYnV0ZSA9IHJlZi5zZXRBdHRyaWJ1dGU7XG5cbiAgICAgICAgICBzZXRBdHRyaWJ1dGUoJ2FVVicsIDIsIGdsLlNUQVRJQ19EUkFXLCAwLCBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAyLCAwLCAwLCAyXSkpO1xuICAgICAgICAgIHNldFVuaWZvcm0oJzFpJywgJ2ltYWdlJywgdGV4VW5pdCk7XG4gICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciB8fCBudWxsKTtcbiAgICAgICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcbiAgICAgICAgICBnbC5jb2xvck1hc2soY2hhbm5lbHMgJiA4LCBjaGFubmVscyAmIDQsIGNoYW5uZWxzICYgMiwgY2hhbm5lbHMgJiAxKTtcbiAgICAgICAgICBnbC52aWV3cG9ydCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICBnbC5zY2lzc29yKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCAzKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNpemluZyBhIGNhbnZhcyBjbGVhcnMgaXRzIGNvbnRlbnRzOyB0aGlzIHV0aWxpdHkgY29waWVzIHRoZSBwcmV2aW91cyBjb250ZW50cyBvdmVyLlxuICAgKiBAcGFyYW0gY2FudmFzXG4gICAqIEBwYXJhbSBuZXdXaWR0aFxuICAgKiBAcGFyYW0gbmV3SGVpZ2h0XG4gICAqL1xuICBmdW5jdGlvbiByZXNpemVXZWJHTENhbnZhc1dpdGhvdXRDbGVhcmluZyhjYW52YXMsIG5ld1dpZHRoLCBuZXdIZWlnaHQpIHtcbiAgICB2YXIgd2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG4gICAgd2l0aFdlYkdMQ29udGV4dChjYW52YXMsIGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgIHZhciBnbCA9IHJlZi5nbDtcblxuICAgICAgdmFyIGRhdGEgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgZ2wucmVhZFBpeGVscygwLCAwLCB3aWR0aCwgaGVpZ2h0LCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBkYXRhKTtcbiAgICAgIGNhbnZhcy53aWR0aCA9IG5ld1dpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgIHJlbmRlckltYWdlRGF0YShnbCwgZGF0YSwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgd2ViZ2xVdGlscyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgd2l0aFdlYkdMQ29udGV4dDogd2l0aFdlYkdMQ29udGV4dCxcbiAgICByZW5kZXJJbWFnZURhdGE6IHJlbmRlckltYWdlRGF0YSxcbiAgICByZXNpemVXZWJHTENhbnZhc1dpdGhvdXRDbGVhcmluZzogcmVzaXplV2ViR0xDYW52YXNXaXRob3V0Q2xlYXJpbmdcbiAgfSk7XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGUkMiAoc2RmV2lkdGgsIHNkZkhlaWdodCwgcGF0aCwgdmlld0JveCwgbWF4RGlzdGFuY2UsIHNkZkV4cG9uZW50KSB7XG4gICAgaWYgKCBzZGZFeHBvbmVudCA9PT0gdm9pZCAwICkgc2RmRXhwb25lbnQgPSAxO1xuXG4gICAgdmFyIHRleHR1cmVEYXRhID0gbmV3IFVpbnQ4QXJyYXkoc2RmV2lkdGggKiBzZGZIZWlnaHQpO1xuXG4gICAgdmFyIHZpZXdCb3hXaWR0aCA9IHZpZXdCb3hbMl0gLSB2aWV3Qm94WzBdO1xuICAgIHZhciB2aWV3Qm94SGVpZ2h0ID0gdmlld0JveFszXSAtIHZpZXdCb3hbMV07XG5cbiAgICAvLyBEZWNvbXBvc2UgYWxsIHBhdGhzIGludG8gc3RyYWlnaHQgbGluZSBzZWdtZW50cyBhbmQgYWRkIHRoZW0gdG8gYW4gaW5kZXhcbiAgICB2YXIgc2VnbWVudHMgPSBbXTtcbiAgICBwYXRoVG9MaW5lU2VnbWVudHMocGF0aCwgZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICBzZWdtZW50cy5wdXNoKHtcbiAgICAgICAgeDE6IHgxLCB5MTogeTEsIHgyOiB4MiwgeTI6IHkyLFxuICAgICAgICBtaW5YOiBNYXRoLm1pbih4MSwgeDIpLFxuICAgICAgICBtaW5ZOiBNYXRoLm1pbih5MSwgeTIpLFxuICAgICAgICBtYXhYOiBNYXRoLm1heCh4MSwgeDIpLFxuICAgICAgICBtYXhZOiBNYXRoLm1heCh5MSwgeTIpXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIFNvcnQgc2VnbWVudHMgYnkgbWF4WCwgdGhpcyB3aWxsIGxldCB1cyBzaG9ydC1jaXJjdWl0IHNvbWUgbG9vcHMgYmVsb3dcbiAgICBzZWdtZW50cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLm1heFggLSBiLm1heFg7IH0pO1xuXG4gICAgLy8gRm9yIGVhY2ggdGFyZ2V0IFNERiB0ZXhlbCwgZmluZCB0aGUgZGlzdGFuY2UgZnJvbSBpdHMgY2VudGVyIHRvIGl0cyBuZWFyZXN0IGxpbmUgc2VnbWVudCxcbiAgICAvLyBtYXAgdGhhdCBkaXN0YW5jZSB0byBhbiBhbHBoYSB2YWx1ZSwgYW5kIHdyaXRlIHRoYXQgYWxwaGEgdG8gdGhlIHRleGVsXG4gICAgZm9yICh2YXIgc2RmWCA9IDA7IHNkZlggPCBzZGZXaWR0aDsgc2RmWCsrKSB7XG4gICAgICBmb3IgKHZhciBzZGZZID0gMDsgc2RmWSA8IHNkZkhlaWdodDsgc2RmWSsrKSB7XG4gICAgICAgIHZhciBzaWduZWREaXN0ID0gZmluZE5lYXJlc3RTaWduZWREaXN0YW5jZShcbiAgICAgICAgICB2aWV3Qm94WzBdICsgdmlld0JveFdpZHRoICogKHNkZlggKyAwLjUpIC8gc2RmV2lkdGgsXG4gICAgICAgICAgdmlld0JveFsxXSArIHZpZXdCb3hIZWlnaHQgKiAoc2RmWSArIDAuNSkgLyBzZGZIZWlnaHRcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBVc2UgYW4gZXhwb25lbnRpYWwgc2NhbGUgdG8gZW5zdXJlIHRoZSB0ZXhlbHMgdmVyeSBuZWFyIHRoZSBnbHlwaCBwYXRoIGhhdmUgYWRlcXVhdGVcbiAgICAgICAgLy8gcHJlY2lzaW9uLCB3aGlsZSBhbGxvd2luZyB0aGUgZGlzdGFuY2UgZmllbGQgdG8gY292ZXIgdGhlIGVudGlyZSB0ZXh0dXJlLCBnaXZlbiB0aGF0XG4gICAgICAgIC8vIHRoZXJlIGFyZSBvbmx5IDggYml0cyBhdmFpbGFibGUuIEZvcm11bGEgdmlzdWFsaXplZDogaHR0cHM6Ly93d3cuZGVzbW9zLmNvbS9jYWxjdWxhdG9yL3VpYXE1YXFpYW1cbiAgICAgICAgdmFyIGFscGhhID0gTWF0aC5wb3coKDEgLSBNYXRoLmFicyhzaWduZWREaXN0KSAvIG1heERpc3RhbmNlKSwgc2RmRXhwb25lbnQpIC8gMjtcbiAgICAgICAgaWYgKHNpZ25lZERpc3QgPCAwKSB7XG4gICAgICAgICAgYWxwaGEgPSAxIC0gYWxwaGE7XG4gICAgICAgIH1cblxuICAgICAgICBhbHBoYSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZChhbHBoYSAqIDI1NSkpKTsgLy9jbGFtcFxuICAgICAgICB0ZXh0dXJlRGF0YVtzZGZZICogc2RmV2lkdGggKyBzZGZYXSA9IGFscGhhO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0ZXh0dXJlRGF0YVxuXG4gICAgLyoqXG4gICAgICogRm9yIGEgZ2l2ZW4geC95LCBzZWFyY2ggdGhlIGluZGV4IGZvciB0aGUgY2xvc2VzdCBsaW5lIHNlZ21lbnQgYW5kIHJldHVyblxuICAgICAqIGl0cyBzaWduZWQgZGlzdGFuY2UuIE5lZ2F0aXZlID0gaW5zaWRlLCBwb3NpdGl2ZSA9IG91dHNpZGUsIHplcm8gPSBvbiBlZGdlXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZE5lYXJlc3RTaWduZWREaXN0YW5jZSAoeCwgeSkge1xuICAgICAgdmFyIGNsb3Nlc3REaXN0U3EgPSBJbmZpbml0eTtcbiAgICAgIHZhciBjbG9zZXN0RGlzdCA9IEluZmluaXR5O1xuXG4gICAgICBmb3IgKHZhciBpID0gc2VnbWVudHMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIHZhciBzZWcgPSBzZWdtZW50c1tpXTtcbiAgICAgICAgaWYgKHNlZy5tYXhYICsgY2xvc2VzdERpc3QgPD0geCkgeyBicmVhayB9IC8vc29ydGluZyBieSBtYXhYIG1lYW5zIG5vIG1vcmUgY2FuIGJlIGNsb3Nlciwgc28gd2UgY2FuIHNob3J0LWNpcmN1aXRcbiAgICAgICAgaWYgKHggKyBjbG9zZXN0RGlzdCA+IHNlZy5taW5YICYmIHkgLSBjbG9zZXN0RGlzdCA8IHNlZy5tYXhZICYmIHkgKyBjbG9zZXN0RGlzdCA+IHNlZy5taW5ZKSB7XG4gICAgICAgICAgdmFyIGRpc3RTcSA9IGFic1NxdWFyZURpc3RhbmNlVG9MaW5lU2VnbWVudCh4LCB5LCBzZWcueDEsIHNlZy55MSwgc2VnLngyLCBzZWcueTIpO1xuICAgICAgICAgIGlmIChkaXN0U3EgPCBjbG9zZXN0RGlzdFNxKSB7XG4gICAgICAgICAgICBjbG9zZXN0RGlzdFNxID0gZGlzdFNxO1xuICAgICAgICAgICAgY2xvc2VzdERpc3QgPSBNYXRoLnNxcnQoY2xvc2VzdERpc3RTcSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEZsaXAgdG8gbmVnYXRpdmUgZGlzdGFuY2UgaWYgaW5zaWRlIHRoZSBwb2x5XG4gICAgICBpZiAoaXNQb2ludEluUG9seSh4LCB5KSkge1xuICAgICAgICBjbG9zZXN0RGlzdCA9IC1jbG9zZXN0RGlzdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbG9zZXN0RGlzdFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB3aGV0aGVyIHRoZSBnaXZlbiBwb2ludCBsaWVzIGluc2lkZSBvciBvdXRzaWRlIHRoZSBnbHlwaC4gVXNlcyBhIHNpbXBsZVxuICAgICAqIHdpbmRpbmctbnVtYmVyIHJheSBjYXN0aW5nIGFsZ29yaXRobSB1c2luZyBhIHJheSBwb2ludGluZyBlYXN0IGZyb20gdGhlIHBvaW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUG9pbnRJblBvbHkgKHgsIHkpIHtcbiAgICAgIHZhciB3aW5kaW5nID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSBzZWdtZW50cy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgdmFyIHNlZyA9IHNlZ21lbnRzW2ldO1xuICAgICAgICBpZiAoc2VnLm1heFggPD0geCkgeyBicmVhayB9IC8vc29ydGluZyBieSBtYXhYIG1lYW5zIG5vIG1vcmUgY2FuIGNyb3NzLCBzbyB3ZSBjYW4gc2hvcnQtY2lyY3VpdFxuICAgICAgICB2YXIgaW50ZXJzZWN0cyA9ICgoc2VnLnkxID4geSkgIT09IChzZWcueTIgPiB5KSkgJiYgKHggPCAoc2VnLngyIC0gc2VnLngxKSAqICh5IC0gc2VnLnkxKSAvIChzZWcueTIgLSBzZWcueTEpICsgc2VnLngxKTtcbiAgICAgICAgaWYgKGludGVyc2VjdHMpIHtcbiAgICAgICAgICB3aW5kaW5nICs9IHNlZy55MSA8IHNlZy55MiA/IDEgOiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHdpbmRpbmcgIT09IDBcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZUludG9DYW52YXMkMihzZGZXaWR0aCwgc2RmSGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBtYXhEaXN0YW5jZSwgc2RmRXhwb25lbnQsIGNhbnZhcywgeCwgeSwgY2hhbm5lbCkge1xuICAgIGlmICggc2RmRXhwb25lbnQgPT09IHZvaWQgMCApIHNkZkV4cG9uZW50ID0gMTtcbiAgICBpZiAoIHggPT09IHZvaWQgMCApIHggPSAwO1xuICAgIGlmICggeSA9PT0gdm9pZCAwICkgeSA9IDA7XG4gICAgaWYgKCBjaGFubmVsID09PSB2b2lkIDAgKSBjaGFubmVsID0gMDtcblxuICAgIGdlbmVyYXRlSW50b0ZyYW1lYnVmZmVyJDEoc2RmV2lkdGgsIHNkZkhlaWdodCwgcGF0aCwgdmlld0JveCwgbWF4RGlzdGFuY2UsIHNkZkV4cG9uZW50LCBjYW52YXMsIG51bGwsIHgsIHksIGNoYW5uZWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVJbnRvRnJhbWVidWZmZXIkMSAoc2RmV2lkdGgsIHNkZkhlaWdodCwgcGF0aCwgdmlld0JveCwgbWF4RGlzdGFuY2UsIHNkZkV4cG9uZW50LCBnbE9yQ2FudmFzLCBmcmFtZWJ1ZmZlciwgeCwgeSwgY2hhbm5lbCkge1xuICAgIGlmICggc2RmRXhwb25lbnQgPT09IHZvaWQgMCApIHNkZkV4cG9uZW50ID0gMTtcbiAgICBpZiAoIHggPT09IHZvaWQgMCApIHggPSAwO1xuICAgIGlmICggeSA9PT0gdm9pZCAwICkgeSA9IDA7XG4gICAgaWYgKCBjaGFubmVsID09PSB2b2lkIDAgKSBjaGFubmVsID0gMDtcblxuICAgIHZhciBkYXRhID0gZ2VuZXJhdGUkMihzZGZXaWR0aCwgc2RmSGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBtYXhEaXN0YW5jZSwgc2RmRXhwb25lbnQpO1xuICAgIC8vIEV4cGFuZCBzaW5nbGUtY2hhbm5lbCBkYXRhIHRvIHJiZ2FcbiAgICB2YXIgcmdiYURhdGEgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCAqIDQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgcmdiYURhdGFbaSAqIDQgKyBjaGFubmVsXSA9IGRhdGFbaV07XG4gICAgfVxuICAgIHJlbmRlckltYWdlRGF0YShnbE9yQ2FudmFzLCByZ2JhRGF0YSwgeCwgeSwgc2RmV2lkdGgsIHNkZkhlaWdodCwgMSA8PCAoMyAtIGNoYW5uZWwpLCBmcmFtZWJ1ZmZlcik7XG4gIH1cblxuICAvKipcbiAgICogRmluZCB0aGUgYWJzb2x1dGUgZGlzdGFuY2UgZnJvbSBhIHBvaW50IHRvIGEgbGluZSBzZWdtZW50IGF0IGNsb3Nlc3QgYXBwcm9hY2hcbiAgICovXG4gIGZ1bmN0aW9uIGFic1NxdWFyZURpc3RhbmNlVG9MaW5lU2VnbWVudCAoeCwgeSwgbGluZVgwLCBsaW5lWTAsIGxpbmVYMSwgbGluZVkxKSB7XG4gICAgdmFyIGxkeCA9IGxpbmVYMSAtIGxpbmVYMDtcbiAgICB2YXIgbGR5ID0gbGluZVkxIC0gbGluZVkwO1xuICAgIHZhciBsZW5ndGhTcSA9IGxkeCAqIGxkeCArIGxkeSAqIGxkeTtcbiAgICB2YXIgdCA9IGxlbmd0aFNxID8gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKCh4IC0gbGluZVgwKSAqIGxkeCArICh5IC0gbGluZVkwKSAqIGxkeSkgLyBsZW5ndGhTcSkpIDogMDtcbiAgICB2YXIgZHggPSB4IC0gKGxpbmVYMCArIHQgKiBsZHgpO1xuICAgIHZhciBkeSA9IHkgLSAobGluZVkwICsgdCAqIGxkeSk7XG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5XG4gIH1cblxuICB2YXIgamF2YXNjcmlwdCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZ2VuZXJhdGU6IGdlbmVyYXRlJDIsXG4gICAgZ2VuZXJhdGVJbnRvQ2FudmFzOiBnZW5lcmF0ZUludG9DYW52YXMkMixcbiAgICBnZW5lcmF0ZUludG9GcmFtZWJ1ZmZlcjogZ2VuZXJhdGVJbnRvRnJhbWVidWZmZXIkMVxuICB9KTtcblxuICB2YXIgbWFpblZlcnRleCA9IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O3VuaWZvcm0gdmVjNCB1R2x5cGhCb3VuZHM7YXR0cmlidXRlIHZlYzIgYVVWO2F0dHJpYnV0ZSB2ZWM0IGFMaW5lU2VnbWVudDt2YXJ5aW5nIHZlYzQgdkxpbmVTZWdtZW50O3ZhcnlpbmcgdmVjMiB2R2x5cGhYWTt2b2lkIG1haW4oKXt2TGluZVNlZ21lbnQ9YUxpbmVTZWdtZW50O3ZHbHlwaFhZPW1peCh1R2x5cGhCb3VuZHMueHksdUdseXBoQm91bmRzLnp3LGFVVik7Z2xfUG9zaXRpb249dmVjNChtaXgodmVjMigtMS4wKSx2ZWMyKDEuMCksYVVWKSwwLjAsMS4wKTt9XCI7XG5cbiAgdmFyIG1haW5GcmFnbWVudCA9IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O3VuaWZvcm0gdmVjNCB1R2x5cGhCb3VuZHM7dW5pZm9ybSBmbG9hdCB1TWF4RGlzdGFuY2U7dW5pZm9ybSBmbG9hdCB1RXhwb25lbnQ7dmFyeWluZyB2ZWM0IHZMaW5lU2VnbWVudDt2YXJ5aW5nIHZlYzIgdkdseXBoWFk7ZmxvYXQgYWJzRGlzdFRvU2VnbWVudCh2ZWMyIHBvaW50LHZlYzIgbGluZUEsdmVjMiBsaW5lQil7dmVjMiBsaW5lRGlyPWxpbmVCLWxpbmVBO2Zsb2F0IGxlblNxPWRvdChsaW5lRGlyLGxpbmVEaXIpO2Zsb2F0IHQ9bGVuU3E9PTAuMCA/IDAuMCA6IGNsYW1wKGRvdChwb2ludC1saW5lQSxsaW5lRGlyKS9sZW5TcSwwLjAsMS4wKTt2ZWMyIGxpbmVQdD1saW5lQSt0KmxpbmVEaXI7cmV0dXJuIGRpc3RhbmNlKHBvaW50LGxpbmVQdCk7fXZvaWQgbWFpbigpe3ZlYzQgc2VnPXZMaW5lU2VnbWVudDt2ZWMyIHA9dkdseXBoWFk7ZmxvYXQgZGlzdD1hYnNEaXN0VG9TZWdtZW50KHAsc2VnLnh5LHNlZy56dyk7ZmxvYXQgdmFsPXBvdygxLjAtY2xhbXAoZGlzdC91TWF4RGlzdGFuY2UsMC4wLDEuMCksdUV4cG9uZW50KSowLjU7Ym9vbCBjcm9zc2luZz0oc2VnLnk+cC55IT1zZWcudz5wLnkpJiYocC54PChzZWcuei1zZWcueCkqKHAueS1zZWcueSkvKHNlZy53LXNlZy55KStzZWcueCk7Ym9vbCBjcm9zc2luZ1VwPWNyb3NzaW5nJiZ2TGluZVNlZ21lbnQueTx2TGluZVNlZ21lbnQudztnbF9GcmFnQ29sb3I9dmVjNChjcm9zc2luZ1VwID8gMS4wLzI1NS4wIDogMC4wLGNyb3NzaW5nJiYhY3Jvc3NpbmdVcCA/IDEuMC8yNTUuMCA6IDAuMCwwLjAsdmFsKTt9XCI7XG5cbiAgdmFyIHBvc3RGcmFnbWVudCA9IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O3VuaWZvcm0gc2FtcGxlcjJEIHRleDt2YXJ5aW5nIHZlYzIgdlVWO3ZvaWQgbWFpbigpe3ZlYzQgY29sb3I9dGV4dHVyZTJEKHRleCx2VVYpO2Jvb2wgaW5zaWRlPWNvbG9yLnIhPWNvbG9yLmc7ZmxvYXQgdmFsPWluc2lkZSA/IDEuMC1jb2xvci5hIDogY29sb3IuYTtnbF9GcmFnQ29sb3I9dmVjNCh2YWwpO31cIjtcblxuICAvLyBTaW5nbGUgdHJpYW5nbGUgY292ZXJpbmcgdmlld3BvcnRcbiAgdmFyIHZpZXdwb3J0VVZzID0gbmV3IEZsb2F0MzJBcnJheShbMCwgMCwgMiwgMCwgMCwgMl0pO1xuXG4gIHZhciBpbXBsaWNpdENvbnRleHQgPSBudWxsO1xuICB2YXIgaXNUZXN0aW5nU3VwcG9ydCA9IGZhbHNlO1xuICB2YXIgTlVMTF9PQkpFQ1QgPSB7fTtcbiAgdmFyIHN1cHBvcnRCeUNhbnZhcyA9IG5ldyBXZWFrTWFwKCk7IC8vIGNhbnZhcyAtPiBib29sXG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVTdXBwb3J0IChnbE9yQ2FudmFzKSB7XG4gICAgaWYgKCFpc1Rlc3RpbmdTdXBwb3J0ICYmICFpc1N1cHBvcnRlZChnbE9yQ2FudmFzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJHTCBnZW5lcmF0aW9uIG5vdCBzdXBwb3J0ZWQnKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlJDEgKHNkZldpZHRoLCBzZGZIZWlnaHQsIHBhdGgsIHZpZXdCb3gsIG1heERpc3RhbmNlLCBzZGZFeHBvbmVudCwgZ2xPckNhbnZhcykge1xuICAgIGlmICggc2RmRXhwb25lbnQgPT09IHZvaWQgMCApIHNkZkV4cG9uZW50ID0gMTtcbiAgICBpZiAoIGdsT3JDYW52YXMgPT09IHZvaWQgMCApIGdsT3JDYW52YXMgPSBudWxsO1xuXG4gICAgaWYgKCFnbE9yQ2FudmFzKSB7XG4gICAgICBnbE9yQ2FudmFzID0gaW1wbGljaXRDb250ZXh0O1xuICAgICAgaWYgKCFnbE9yQ2FudmFzKSB7XG4gICAgICAgIHZhciBjYW52YXMgPSB0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgPyBuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsIDEpXG4gICAgICAgICAgOiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPZmZzY3JlZW5DYW52YXMgb3IgRE9NIGNhbnZhcyBub3Qgc3VwcG9ydGVkJylcbiAgICAgICAgfVxuICAgICAgICBnbE9yQ2FudmFzID0gaW1wbGljaXRDb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgeyBkZXB0aDogZmFsc2UgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFsaWRhdGVTdXBwb3J0KGdsT3JDYW52YXMpO1xuXG4gICAgdmFyIHJnYmFEYXRhID0gbmV3IFVpbnQ4QXJyYXkoc2RmV2lkdGggKiBzZGZIZWlnaHQgKiA0KTsgLy9ub3QgVWludDhDbGFtcGVkQXJyYXksIGN1eiBTYWZhcmlcblxuICAgIC8vIFJlbmRlciBpbnRvIGEgYmFja2dyb3VuZCB0ZXh0dXJlIGZyYW1lYnVmZmVyXG4gICAgd2l0aFdlYkdMQ29udGV4dChnbE9yQ2FudmFzLCBmdW5jdGlvbiAocmVmKSB7XG4gICAgICB2YXIgZ2wgPSByZWYuZ2w7XG4gICAgICB2YXIgd2l0aFRleHR1cmUgPSByZWYud2l0aFRleHR1cmU7XG4gICAgICB2YXIgd2l0aFRleHR1cmVGcmFtZWJ1ZmZlciA9IHJlZi53aXRoVGV4dHVyZUZyYW1lYnVmZmVyO1xuXG4gICAgICB3aXRoVGV4dHVyZSgncmVhZGFibGUnLCBmdW5jdGlvbiAodGV4dHVyZSwgdGV4dHVyZVVuaXQpIHtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBzZGZXaWR0aCwgc2RmSGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcblxuICAgICAgICB3aXRoVGV4dHVyZUZyYW1lYnVmZmVyKHRleHR1cmUsIHRleHR1cmVVbml0LCBmdW5jdGlvbiAoZnJhbWVidWZmZXIpIHtcbiAgICAgICAgICBnZW5lcmF0ZUludG9GcmFtZWJ1ZmZlcihcbiAgICAgICAgICAgIHNkZldpZHRoLFxuICAgICAgICAgICAgc2RmSGVpZ2h0LFxuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIHZpZXdCb3gsXG4gICAgICAgICAgICBtYXhEaXN0YW5jZSxcbiAgICAgICAgICAgIHNkZkV4cG9uZW50LFxuICAgICAgICAgICAgZ2wsXG4gICAgICAgICAgICBmcmFtZWJ1ZmZlcixcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCAvLyByZWQgY2hhbm5lbFxuICAgICAgICAgICk7XG4gICAgICAgICAgZ2wucmVhZFBpeGVscygwLCAwLCBzZGZXaWR0aCwgc2RmSGVpZ2h0LCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCByZ2JhRGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBUaHJvdyBhd2F5IGFsbCBidXQgdGhlIHJlZCBjaGFubmVsXG4gICAgdmFyIGRhdGEgPSBuZXcgVWludDhBcnJheShzZGZXaWR0aCAqIHNkZkhlaWdodCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSAwOyBpIDwgcmdiYURhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgIGRhdGFbaisrXSA9IHJnYmFEYXRhW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhXG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZUludG9DYW52YXMkMShzZGZXaWR0aCwgc2RmSGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBtYXhEaXN0YW5jZSwgc2RmRXhwb25lbnQsIGNhbnZhcywgeCwgeSwgY2hhbm5lbCkge1xuICAgIGlmICggc2RmRXhwb25lbnQgPT09IHZvaWQgMCApIHNkZkV4cG9uZW50ID0gMTtcbiAgICBpZiAoIHggPT09IHZvaWQgMCApIHggPSAwO1xuICAgIGlmICggeSA9PT0gdm9pZCAwICkgeSA9IDA7XG4gICAgaWYgKCBjaGFubmVsID09PSB2b2lkIDAgKSBjaGFubmVsID0gMDtcblxuICAgIGdlbmVyYXRlSW50b0ZyYW1lYnVmZmVyKHNkZldpZHRoLCBzZGZIZWlnaHQsIHBhdGgsIHZpZXdCb3gsIG1heERpc3RhbmNlLCBzZGZFeHBvbmVudCwgY2FudmFzLCBudWxsLCB4LCB5LCBjaGFubmVsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlSW50b0ZyYW1lYnVmZmVyIChzZGZXaWR0aCwgc2RmSGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBtYXhEaXN0YW5jZSwgc2RmRXhwb25lbnQsIGdsT3JDYW52YXMsIGZyYW1lYnVmZmVyLCB4LCB5LCBjaGFubmVsKSB7XG4gICAgaWYgKCBzZGZFeHBvbmVudCA9PT0gdm9pZCAwICkgc2RmRXhwb25lbnQgPSAxO1xuICAgIGlmICggeCA9PT0gdm9pZCAwICkgeCA9IDA7XG4gICAgaWYgKCB5ID09PSB2b2lkIDAgKSB5ID0gMDtcbiAgICBpZiAoIGNoYW5uZWwgPT09IHZvaWQgMCApIGNoYW5uZWwgPSAwO1xuXG4gICAgLy8gVmVyaWZ5IHN1cHBvcnRcbiAgICB2YWxpZGF0ZVN1cHBvcnQoZ2xPckNhbnZhcyk7XG5cbiAgICAvLyBDb21wdXRlIHBhdGggc2VnbWVudHNcbiAgICB2YXIgbGluZVNlZ21lbnRDb29yZHMgPSBbXTtcbiAgICBwYXRoVG9MaW5lU2VnbWVudHMocGF0aCwgZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICBsaW5lU2VnbWVudENvb3Jkcy5wdXNoKHgxLCB5MSwgeDIsIHkyKTtcbiAgICB9KTtcbiAgICBsaW5lU2VnbWVudENvb3JkcyA9IG5ldyBGbG9hdDMyQXJyYXkobGluZVNlZ21lbnRDb29yZHMpO1xuXG4gICAgd2l0aFdlYkdMQ29udGV4dChnbE9yQ2FudmFzLCBmdW5jdGlvbiAocmVmKSB7XG4gICAgICB2YXIgZ2wgPSByZWYuZ2w7XG4gICAgICB2YXIgaXNXZWJHTDIgPSByZWYuaXNXZWJHTDI7XG4gICAgICB2YXIgZ2V0RXh0ZW5zaW9uID0gcmVmLmdldEV4dGVuc2lvbjtcbiAgICAgIHZhciB3aXRoUHJvZ3JhbSA9IHJlZi53aXRoUHJvZ3JhbTtcbiAgICAgIHZhciB3aXRoVGV4dHVyZSA9IHJlZi53aXRoVGV4dHVyZTtcbiAgICAgIHZhciB3aXRoVGV4dHVyZUZyYW1lYnVmZmVyID0gcmVmLndpdGhUZXh0dXJlRnJhbWVidWZmZXI7XG4gICAgICB2YXIgaGFuZGxlQ29udGV4dExvc3MgPSByZWYuaGFuZGxlQ29udGV4dExvc3M7XG5cbiAgICAgIHdpdGhUZXh0dXJlKCdyYXdEaXN0YW5jZXMnLCBmdW5jdGlvbiAoaW50ZXJtZWRpYXRlVGV4dHVyZSwgaW50ZXJtZWRpYXRlVGV4dHVyZVVuaXQpIHtcbiAgICAgICAgaWYgKHNkZldpZHRoICE9PSBpbnRlcm1lZGlhdGVUZXh0dXJlLl9sYXN0V2lkdGggfHwgc2RmSGVpZ2h0ICE9PSBpbnRlcm1lZGlhdGVUZXh0dXJlLl9sYXN0SGVpZ2h0KSB7XG4gICAgICAgICAgZ2wudGV4SW1hZ2UyRChcbiAgICAgICAgICAgIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsXG4gICAgICAgICAgICBpbnRlcm1lZGlhdGVUZXh0dXJlLl9sYXN0V2lkdGggPSBzZGZXaWR0aCxcbiAgICAgICAgICAgIGludGVybWVkaWF0ZVRleHR1cmUuX2xhc3RIZWlnaHQgPSBzZGZIZWlnaHQsXG4gICAgICAgICAgICAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVuc2lnbmVkIGRpc3RhbmNlIHBhc3NcbiAgICAgICAgd2l0aFByb2dyYW0oJ21haW4nLCBtYWluVmVydGV4LCBtYWluRnJhZ21lbnQsIGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICB2YXIgc2V0QXR0cmlidXRlID0gcmVmLnNldEF0dHJpYnV0ZTtcbiAgICAgICAgICB2YXIgc2V0VW5pZm9ybSA9IHJlZi5zZXRVbmlmb3JtO1xuXG4gICAgICAgICAgLy8gSW5pdCBleHRlbnNpb25zXG4gICAgICAgICAgdmFyIGluc3RhbmNpbmdFeHRlbnNpb24gPSAhaXNXZWJHTDIgJiYgZ2V0RXh0ZW5zaW9uKCdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyk7XG4gICAgICAgICAgdmFyIGJsZW5kTWluTWF4RXh0ZW5zaW9uID0gIWlzV2ViR0wyICYmIGdldEV4dGVuc2lvbignRVhUX2JsZW5kX21pbm1heCcpO1xuXG4gICAgICAgICAgLy8gSW5pdC91cGRhdGUgYXR0cmlidXRlc1xuICAgICAgICAgIHNldEF0dHJpYnV0ZSgnYVVWJywgMiwgZ2wuU1RBVElDX0RSQVcsIDAsIHZpZXdwb3J0VVZzKTtcbiAgICAgICAgICBzZXRBdHRyaWJ1dGUoJ2FMaW5lU2VnbWVudCcsIDQsIGdsLkRZTkFNSUNfRFJBVywgMSwgbGluZVNlZ21lbnRDb29yZHMpO1xuXG4gICAgICAgICAgLy8gSW5pdC91cGRhdGUgdW5pZm9ybXNcbiAgICAgICAgICBzZXRVbmlmb3JtLmFwcGx5KHZvaWQgMCwgWyAnNGYnLCAndUdseXBoQm91bmRzJyBdLmNvbmNhdCggdmlld0JveCApKTtcbiAgICAgICAgICBzZXRVbmlmb3JtKCcxZicsICd1TWF4RGlzdGFuY2UnLCBtYXhEaXN0YW5jZSk7XG4gICAgICAgICAgc2V0VW5pZm9ybSgnMWYnLCAndUV4cG9uZW50Jywgc2RmRXhwb25lbnQpO1xuXG4gICAgICAgICAgLy8gUmVuZGVyIGluaXRpYWwgdW5zaWduZWQgZGlzdGFuY2UgLyB3aW5kaW5nIG51bWJlciBpbmZvIHRvIGEgdGV4dHVyZVxuICAgICAgICAgIHdpdGhUZXh0dXJlRnJhbWVidWZmZXIoaW50ZXJtZWRpYXRlVGV4dHVyZSwgaW50ZXJtZWRpYXRlVGV4dHVyZVVuaXQsIGZ1bmN0aW9uIChmcmFtZWJ1ZmZlcikge1xuICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICAgICAgICAgIGdsLmNvbG9yTWFzayh0cnVlLCB0cnVlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIHNkZldpZHRoLCBzZGZIZWlnaHQpO1xuICAgICAgICAgICAgZ2wuc2Npc3NvcigwLCAwLCBzZGZXaWR0aCwgc2RmSGVpZ2h0KTtcbiAgICAgICAgICAgIGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORSk7XG4gICAgICAgICAgICAvLyBSZWQrR3JlZW4gY2hhbm5lbHMgYXJlIGluY3JlbWVudGVkIChGVU5DX0FERCkgZm9yIHNlZ21lbnQtcmF5IGNyb3NzaW5ncyB0byBnaXZlIGEgXCJ3aW5kaW5nIG51bWJlclwiLlxuICAgICAgICAgICAgLy8gQWxwaGEgaG9sZHMgdGhlIGNsb3Nlc3QgKE1BWCkgdW5zaWduZWQgZGlzdGFuY2UuXG4gICAgICAgICAgICBnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoZ2wuRlVOQ19BREQsIGlzV2ViR0wyID8gZ2wuTUFYIDogYmxlbmRNaW5NYXhFeHRlbnNpb24uTUFYX0VYVCk7XG4gICAgICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcbiAgICAgICAgICAgIGlmIChpc1dlYkdMMikge1xuICAgICAgICAgICAgICBnbC5kcmF3QXJyYXlzSW5zdGFuY2VkKGdsLlRSSUFOR0xFUywgMCwgMywgbGluZVNlZ21lbnRDb29yZHMubGVuZ3RoIC8gNCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbnN0YW5jaW5nRXh0ZW5zaW9uLmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRShnbC5UUklBTkdMRVMsIDAsIDMsIGxpbmVTZWdtZW50Q29vcmRzLmxlbmd0aCAvIDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGVidWdcbiAgICAgICAgICAgIC8vIGNvbnN0IGRlYnVnID0gbmV3IFVpbnQ4QXJyYXkoc2RmV2lkdGggKiBzZGZIZWlnaHQgKiA0KVxuICAgICAgICAgICAgLy8gZ2wucmVhZFBpeGVscygwLCAwLCBzZGZXaWR0aCwgc2RmSGVpZ2h0LCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBkZWJ1ZylcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdpbnRlcm1lZGlhdGUgdGV4dHVyZSBkYXRhOiAnLCBkZWJ1ZylcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVXNlIHRoZSBkYXRhIHN0b3JlZCBpbiB0aGUgdGV4dHVyZSB0byBhcHBseSBpbnNpZGUvb3V0c2lkZSBhbmQgd3JpdGUgdG8gdGhlIG91dHB1dCBmcmFtZWJ1ZmZlciByZWN0K2NoYW5uZWwuXG4gICAgICAgIHdpdGhQcm9ncmFtKCdwb3N0Jywgdmlld3BvcnRRdWFkVmVydGV4LCBwb3N0RnJhZ21lbnQsIGZ1bmN0aW9uIChwcm9ncmFtKSB7XG4gICAgICAgICAgcHJvZ3JhbS5zZXRBdHRyaWJ1dGUoJ2FVVicsIDIsIGdsLlNUQVRJQ19EUkFXLCAwLCB2aWV3cG9ydFVWcyk7XG4gICAgICAgICAgcHJvZ3JhbS5zZXRVbmlmb3JtKCcxaScsICd0ZXgnLCBpbnRlcm1lZGlhdGVUZXh0dXJlVW5pdCk7XG4gICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlcik7XG4gICAgICAgICAgZ2wuZGlzYWJsZShnbC5CTEVORCk7XG4gICAgICAgICAgZ2wuY29sb3JNYXNrKGNoYW5uZWwgPT09IDAsIGNoYW5uZWwgPT09IDEsIGNoYW5uZWwgPT09IDIsIGNoYW5uZWwgPT09IDMpO1xuICAgICAgICAgIGdsLnZpZXdwb3J0KHgsIHksIHNkZldpZHRoLCBzZGZIZWlnaHQpO1xuICAgICAgICAgIGdsLnNjaXNzb3IoeCwgeSwgc2RmV2lkdGgsIHNkZkhlaWdodCk7XG4gICAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIDMpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBIYW5kbGUgY29udGV4dCBsb3NzIG9jY3VycmluZyBkdXJpbmcgYW55IG9mIHRoZSBhYm92ZSBjYWxsc1xuICAgICAgaWYgKGdsLmlzQ29udGV4dExvc3QoKSkge1xuICAgICAgICBoYW5kbGVDb250ZXh0TG9zcygpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dlYmdsIGNvbnRleHQgbG9zdCcpXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc1N1cHBvcnRlZCAoZ2xPckNhbnZhcykge1xuICAgIHZhciBrZXkgPSAoIWdsT3JDYW52YXMgfHwgZ2xPckNhbnZhcyA9PT0gaW1wbGljaXRDb250ZXh0KSA/IE5VTExfT0JKRUNUIDogKGdsT3JDYW52YXMuY2FudmFzIHx8IGdsT3JDYW52YXMpO1xuICAgIHZhciBzdXBwb3J0ZWQgPSBzdXBwb3J0QnlDYW52YXMuZ2V0KGtleSk7XG4gICAgaWYgKHN1cHBvcnRlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpc1Rlc3RpbmdTdXBwb3J0ID0gdHJ1ZTtcbiAgICAgIHZhciBmYWlsUmVhc29uID0gbnVsbDtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFNpbmNlIHdlIGNhbid0IGRldGVjdCBhbGwgZmFpbHVyZSBtb2RlcyB1cCBmcm9udCwgbGV0J3MganVzdCBkbyBhIHRyaWFsIHJ1biBvZiBhXG4gICAgICAgIC8vIHNpbXBsZSBwYXRoIGFuZCBjb21wYXJlIHdoYXQgd2UgZ2V0IGJhY2sgdG8gdGhlIGNvcnJlY3QgZXhwZWN0ZWQgcmVzdWx0LiBUaGlzIHdpbGxcbiAgICAgICAgLy8gYWxzbyBzZXJ2ZSB0byBwcmltZSB0aGUgc2hhZGVyIGNvbXBpbGF0aW9uLlxuICAgICAgICB2YXIgZXhwZWN0ZWRSZXN1bHQgPSBbXG4gICAgICAgICAgOTcsIDEwNiwgOTcsIDYxLFxuICAgICAgICAgIDk5LCAxMzcsIDExOCwgODAsXG4gICAgICAgICAgODAsIDExOCwgMTM3LCA5OSxcbiAgICAgICAgICA2MSwgOTcsIDEwNiwgOTdcbiAgICAgICAgXTtcbiAgICAgICAgdmFyIHRlc3RSZXN1bHQgPSBnZW5lcmF0ZSQxKFxuICAgICAgICAgIDQsXG4gICAgICAgICAgNCxcbiAgICAgICAgICAnTTgsOEwxNiw4TDI0LDI0TDE2LDI0WicsXG4gICAgICAgICAgWzAsIDAsIDMyLCAzMl0sXG4gICAgICAgICAgMjQsXG4gICAgICAgICAgMSxcbiAgICAgICAgICBnbE9yQ2FudmFzXG4gICAgICAgICk7XG4gICAgICAgIHN1cHBvcnRlZCA9IHRlc3RSZXN1bHQgJiYgZXhwZWN0ZWRSZXN1bHQubGVuZ3RoID09PSB0ZXN0UmVzdWx0Lmxlbmd0aCAmJlxuICAgICAgICAgIHRlc3RSZXN1bHQuZXZlcnkoZnVuY3Rpb24gKHZhbCwgaSkgeyByZXR1cm4gdmFsID09PSBleHBlY3RlZFJlc3VsdFtpXTsgfSk7XG4gICAgICAgIGlmICghc3VwcG9ydGVkKSB7XG4gICAgICAgICAgZmFpbFJlYXNvbiA9ICdiYWQgdHJpYWwgcnVuIHJlc3VsdHMnO1xuICAgICAgICAgIGNvbnNvbGUuaW5mbyhleHBlY3RlZFJlc3VsdCwgdGVzdFJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBUT0RPIGlmIGl0IHRocmV3IGR1ZSB0byB3ZWJnbCBjb250ZXh0IGxvc3MsIHNob3VsZCB3ZSBtYXliZSBsZWF2ZSBpc1N1cHBvcnRlZCBhcyBudWxsIGFuZCB0cnkgYWdhaW4gbGF0ZXI/XG4gICAgICAgIHN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICBmYWlsUmVhc29uID0gZXJyLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgICBpZiAoZmFpbFJlYXNvbikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1dlYkdMIFNERiBnZW5lcmF0aW9uIG5vdCBzdXBwb3J0ZWQ6JywgZmFpbFJlYXNvbik7XG4gICAgICB9XG4gICAgICBpc1Rlc3RpbmdTdXBwb3J0ID0gZmFsc2U7XG4gICAgICBzdXBwb3J0QnlDYW52YXMuc2V0KGtleSwgc3VwcG9ydGVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cHBvcnRlZFxuICB9XG5cbiAgdmFyIHdlYmdsID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZW5lcmF0ZTogZ2VuZXJhdGUkMSxcbiAgICBnZW5lcmF0ZUludG9DYW52YXM6IGdlbmVyYXRlSW50b0NhbnZhcyQxLFxuICAgIGdlbmVyYXRlSW50b0ZyYW1lYnVmZmVyOiBnZW5lcmF0ZUludG9GcmFtZWJ1ZmZlcixcbiAgICBpc1N1cHBvcnRlZDogaXNTdXBwb3J0ZWRcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFuIFNERiB0ZXh0dXJlIGltYWdlIGZvciBhIDJEIHBhdGguXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzZGZXaWR0aCAtIHdpZHRoIG9mIHRoZSBTREYgb3V0cHV0IGltYWdlIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNkZkhlaWdodCAtIGhlaWdodCBvZiB0aGUgU0RGIG91dHB1dCBpbWFnZSBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gYW4gU1ZHLWxpa2UgcGF0aCBzdHJpbmcgZGVzY3JpYmluZyB0aGUgZ2x5cGg7IHNob3VsZCBvbmx5IGNvbnRhaW4gY29tbWFuZHM6IE0vTC9RL0MvWi5cbiAgICogQHBhcmFtIHtudW1iZXJbXX0gdmlld0JveCAtIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSBpbiBmb250IHVuaXRzIGFsaWduaW5nIHdpdGggdGhlIHRleHR1cmUncyBlZGdlcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1heERpc3RhbmNlIC0gdGhlIG1heGltdW0gZGlzdGFuY2UgZnJvbSB0aGUgZ2x5cGggcGF0aCBpbiBmb250IHVuaXRzIHRoYXQgd2lsbCBiZSBlbmNvZGVkOyBkZWZhdWx0c1xuICAgKiAgICAgICAgdG8gaGFsZiB0aGUgbWF4aW11bSB2aWV3Qm94IGRpbWVuc2lvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzZGZFeHBvbmVudF0gLSBzcGVjaWZpZXMgYW4gZXhwb25lbnQgZm9yIGVuY29kaW5nIHRoZSBTREYncyBkaXN0YW5jZSB2YWx1ZXM7IGhpZ2hlciBleHBvbmVudHNcbiAgICogICAgICAgIHdpbGwgZ2l2ZSBncmVhdGVyIHByZWNpc2lvbiBuZWFyZXIgdGhlIGdseXBoJ3MgcGF0aC5cbiAgICogQHJldHVybiB7VWludDhBcnJheX1cbiAgICovXG4gIGZ1bmN0aW9uIGdlbmVyYXRlKFxuICAgIHNkZldpZHRoLFxuICAgIHNkZkhlaWdodCxcbiAgICBwYXRoLFxuICAgIHZpZXdCb3gsXG4gICAgbWF4RGlzdGFuY2UsXG4gICAgc2RmRXhwb25lbnRcbiAgKSB7XG4gICAgaWYgKCBtYXhEaXN0YW5jZSA9PT0gdm9pZCAwICkgbWF4RGlzdGFuY2UgPSBNYXRoLm1heCh2aWV3Qm94WzJdIC0gdmlld0JveFswXSwgdmlld0JveFszXSAtIHZpZXdCb3hbMV0pIC8gMjtcbiAgICBpZiAoIHNkZkV4cG9uZW50ID09PSB2b2lkIDAgKSBzZGZFeHBvbmVudCA9IDE7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGdlbmVyYXRlJDEuYXBwbHkod2ViZ2wsIGFyZ3VtZW50cylcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIGNvbnNvbGUuaW5mbygnV2ViR0wgU0RGIGdlbmVyYXRpb24gZmFpbGVkLCBmYWxsaW5nIGJhY2sgdG8gSlMnLCBlKTtcbiAgICAgIHJldHVybiBnZW5lcmF0ZSQyLmFwcGx5KGphdmFzY3JpcHQsIGFyZ3VtZW50cylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYW4gU0RGIHRleHR1cmUgaW1hZ2UgZm9yIGEgMkQgcGF0aCwgaW5zZXJ0aW5nIHRoZSByZXN1bHQgaW50byBhIFdlYkdMIGBjYW52YXNgIGF0IGEgZ2l2ZW4geC95IHBvc2l0aW9uXG4gICAqIGFuZCBjb2xvciBjaGFubmVsLiBUaGlzIGlzIGdlbmVyYWxseSBtdWNoIGZhc3RlciB0aGFuIGNhbGxpbmcgYGdlbmVyYXRlYCBiZWNhdXNlIGl0IGRvZXMgbm90IHJlcXVpcmUgcmVhZGluZyBwaXhlbHNcbiAgICogYmFjayBmcm9tIHRoZSBHUFUtPkNQVSAtLSB0aGUgYGNhbnZhc2AgY2FuIGJlIHVzZWQgZGlyZWN0bHkgYXMgYSBXZWJHTCB0ZXh0dXJlIGltYWdlLCBzbyBpdCBhbGwgc3RheXMgb24gdGhlIEdQVS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNkZldpZHRoIC0gd2lkdGggb2YgdGhlIFNERiBvdXRwdXQgaW1hZ2UgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2RmSGVpZ2h0IC0gaGVpZ2h0IG9mIHRoZSBTREYgb3V0cHV0IGltYWdlIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSBhbiBTVkctbGlrZSBwYXRoIHN0cmluZyBkZXNjcmliaW5nIHRoZSBnbHlwaDsgc2hvdWxkIG9ubHkgY29udGFpbiBjb21tYW5kczogTS9ML1EvQy9aLlxuICAgKiBAcGFyYW0ge251bWJlcltdfSB2aWV3Qm94IC0gW21pblgsIG1pblksIG1heFgsIG1heFldIGluIGZvbnQgdW5pdHMgYWxpZ25pbmcgd2l0aCB0aGUgdGV4dHVyZSdzIGVkZ2VzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4RGlzdGFuY2UgLSB0aGUgbWF4aW11bSBkaXN0YW5jZSBmcm9tIHRoZSBnbHlwaCBwYXRoIGluIGZvbnQgdW5pdHMgdGhhdCB3aWxsIGJlIGVuY29kZWQ7IGRlZmF1bHRzXG4gICAqICAgICAgICB0byBoYWxmIHRoZSBtYXhpbXVtIHZpZXdCb3ggZGltZW5zaW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NkZkV4cG9uZW50XSAtIHNwZWNpZmllcyBhbiBleHBvbmVudCBmb3IgZW5jb2RpbmcgdGhlIFNERidzIGRpc3RhbmNlIHZhbHVlczsgaGlnaGVyIGV4cG9uZW50c1xuICAgKiAgICAgICAgd2lsbCBnaXZlIGdyZWF0ZXIgcHJlY2lzaW9uIG5lYXJlciB0aGUgZ2x5cGgncyBwYXRoLlxuICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fE9mZnNjcmVlbkNhbnZhc30gY2FudmFzIC0gYSBXZWJHTC1lbmFibGVkIGNhbnZhcyBpbnRvIHdoaWNoIHRoZSBTREYgd2lsbCBiZSByZW5kZXJlZC5cbiAgICogICAgICAgIE9ubHkgdGhlIHJlbGV2YW50IHJlY3QvY2hhbm5lbCB3aWxsIGJlIG1vZGlmaWVkLCB0aGUgcmVzdCB3aWxsIGJlIHByZXNlcnZlZC4gVG8gYXZvaWQgdW5wcmVkaWN0YWJsZSByZXN1bHRzXG4gICAqICAgICAgICBkdWUgdG8gc2hhcmVkIEdMIGNvbnRleHQgc3RhdGUsIHRoaXMgY2FudmFzIHNob3VsZCBiZSBkZWRpY2F0ZWQgdG8gdXNlIGJ5IHRoaXMgbGlicmFyeSBhbG9uZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB0aGUgeCBwb3NpdGlvbiBhdCB3aGljaCB0byByZW5kZXIgdGhlIFNERi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB0aGUgeSBwb3NpdGlvbiBhdCB3aGljaCB0byByZW5kZXIgdGhlIFNERi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGNoYW5uZWwgLSB0aGUgY29sb3IgY2hhbm5lbCBpbmRleCAoMC00KSBpbnRvIHdoaWNoIHRoZSBTREYgd2lsbCBiZSByZW5kZXJlZC5cbiAgICogQHJldHVybiB7VWludDhBcnJheX1cbiAgICovXG4gIGZ1bmN0aW9uIGdlbmVyYXRlSW50b0NhbnZhcyhcbiAgICBzZGZXaWR0aCxcbiAgICBzZGZIZWlnaHQsXG4gICAgcGF0aCxcbiAgICB2aWV3Qm94LFxuICAgIG1heERpc3RhbmNlLFxuICAgIHNkZkV4cG9uZW50LFxuICAgIGNhbnZhcyxcbiAgICB4LFxuICAgIHksXG4gICAgY2hhbm5lbFxuICApIHtcbiAgICBpZiAoIG1heERpc3RhbmNlID09PSB2b2lkIDAgKSBtYXhEaXN0YW5jZSA9IE1hdGgubWF4KHZpZXdCb3hbMl0gLSB2aWV3Qm94WzBdLCB2aWV3Qm94WzNdIC0gdmlld0JveFsxXSkgLyAyO1xuICAgIGlmICggc2RmRXhwb25lbnQgPT09IHZvaWQgMCApIHNkZkV4cG9uZW50ID0gMTtcbiAgICBpZiAoIHggPT09IHZvaWQgMCApIHggPSAwO1xuICAgIGlmICggeSA9PT0gdm9pZCAwICkgeSA9IDA7XG4gICAgaWYgKCBjaGFubmVsID09PSB2b2lkIDAgKSBjaGFubmVsID0gMDtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZ2VuZXJhdGVJbnRvQ2FudmFzJDEuYXBwbHkod2ViZ2wsIGFyZ3VtZW50cylcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIGNvbnNvbGUuaW5mbygnV2ViR0wgU0RGIGdlbmVyYXRpb24gZmFpbGVkLCBmYWxsaW5nIGJhY2sgdG8gSlMnLCBlKTtcbiAgICAgIHJldHVybiBnZW5lcmF0ZUludG9DYW52YXMkMi5hcHBseShqYXZhc2NyaXB0LCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG5cbiAgZXhwb3J0cy5mb3JFYWNoUGF0aENvbW1hbmQgPSBmb3JFYWNoUGF0aENvbW1hbmQ7XG4gIGV4cG9ydHMuZ2VuZXJhdGUgPSBnZW5lcmF0ZTtcbiAgZXhwb3J0cy5nZW5lcmF0ZUludG9DYW52YXMgPSBnZW5lcmF0ZUludG9DYW52YXM7XG4gIGV4cG9ydHMuamF2YXNjcmlwdCA9IGphdmFzY3JpcHQ7XG4gIGV4cG9ydHMucGF0aFRvTGluZVNlZ21lbnRzID0gcGF0aFRvTGluZVNlZ21lbnRzO1xuICBleHBvcnRzLndlYmdsID0gd2ViZ2w7XG4gIGV4cG9ydHMud2ViZ2xVdGlscyA9IHdlYmdsVXRpbHM7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuICByZXR1cm4gZXhwb3J0cztcblxufSh7fSkpO1xucmV0dXJuIGV4cG9ydHNcbn1cblxuZXhwb3J0IHsgU0RGR2VuZXJhdG9yIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs\n");

/***/ })

};
;